前后端交互阶段目录

- 学习Node.js与Ajax阶段的作用是什么

  1. 使用Node/Express搭建静态服务器，提供后端服务
  2. 能够知道Node.js不同模块的作用
  3. 使用MySQL数据库，存储数据
  4. 使用artTemplate模板引擎，高效，快速渲染数据
  5. 使用Ajax请求后端接口，对数据进行增删改查操作
  6. Git项目版本管理工具(上传代码)
  7. GitHub项目(代码)托管平台

- 阶段学习目标

  1. 了解Mysql数据库
  2. 理解Node.js和Express框架的作用
  3. 理解不同包的作用
  4. 能够熟练使用artTemplate**[重要]**
  5. **能够熟练使用Ajax请求后端接口[重要]**
  6. **能够熟练使用Git和GitHub[重要]**

- 阶段课程内容基本信息

- 阶段中知识的重难点

  1. Ajax
  2. Git和GitHub
  3. Node.js和Express框架
  4. artTemplate模板引擎
  5. **前后端交互逻辑思维**

- 阶段包含案例/项目展示

- 阶段模块与学习方法建议

  | 模块名称               | 模块难度 | 掌握程度 | 学习方法建议                                     |
  | ---------------------- | -------- | -------- | ------------------------------------------------ |
  | Ajax+Http              | 3        | 掌握     | 代码多敲多练，培养前后端交互逻辑思维能力【重要】 |
  | Git和GitHub            | 3        | 掌握     | 指令多敲多练【重要】                             |
  | 大事件后台管理系统项目 | 5        | 熟悉     | 代码至少敲1遍，熟悉                              |
  | Node基础               | 4        | 熟悉     | 代码至少敲1遍，熟悉                              |
  | Npm+模块加载机制       | 3        | 熟悉     | 代码至少敲1遍，熟悉                              |
  | Express                | 4        | 熟悉     | 代码至少敲1遍，熟悉                              |
  | Mysql数据库            | 5        | 了解     | 代码至少敲1遍，了解                              |
  | 身份认证               | 3        | 了解     | 代码至少敲1遍，了解                              |
  | NodeApi接口项目        | 5        | 了解     | 代码至少敲1遍，了解                              |

- 阶段中技术点之间的联系



# 1. 服务器的基本概念与初识Ajax

目标

- 能够知道和服务器相关的基本概念
- 能够知道客户端和服务器通信的过程
- 能够知道数据也是一种资源
- 能够说出什么是Ajax以及应用场景
- 能够使用jQuery中的Ajax函数请求数据
- 能够知道接口和接口文档的概念

## 1.1 客户端与服务器

### 1.1.1 上网的目的

上网的**本质目的**：通过互联网的形式来**获取和消费资源**

### 1.1.2 服务器

上网过程中，负责**存放和对外提供资源**的电脑，叫做服务器。

服务器本质：就是一台电脑，只不过，它的性能要比个人电脑高很多。

### 1.1.3 客户端

上网过程中，负责获取和消费资源的电脑，叫做客户端。

个人电脑中，可以通过安装浏览器的形式，访问服务器对外提供的各种资源。

## 1.2 URL地址

### 1.2.1 URL地址的概念

URL（全称是UniformResourceLocator）中文叫**统一资源定位符**，用于标识局联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。

常见的URL举例：

http://www.baidu.com

http://www.taobao.com

http://www.cnblogs.com/liulongbinblogs/p/11649393.html

### 1.2.2 URL地址的组成部分

URL地址一般由三部分组成：

1. 客户端与服务器之间的**通信协议**
2. 存有该资源的**服务器名称**
3. 资源在服务器上**具体的存放位置**

example：

http://www.cnblogs.com/liulongbinblogs/p/11649393.html

其中http是通信协议

www.cnblogs.com是服务器名称

liulongbinblogs/p/11649393.html是资源在服务器上具体的存放位置

## 1.3 分析网页的打开过程

### 1.3.1 图解客户端与服务器的通信过程

1. 客户端(用户的电脑)请求服务器

   （1）打开浏览器 （2）输入要访问的网络地址 （3）回车，向服务器发起资源请求

2. 服务器(web服务器)处理这次请求

   （1）服务器接收到客户端发来的资源请求 （2）服务器在内部处理这次请求，找到相关的资源 （3）服务器把找到的资源，响应(发送)给客户端

3. 服务器响应客户端

**注意：**

（1）客户端与服务器之间的通信过程，分为**请求-处理-响应**三个步骤。

（2）网页中的每一个资源，都是通过**请求-处理-响应**的方式从服务器获取回来的。

### 1.3.2 基于浏览器的开发者工具分析通信过程

1. 打开Chrome浏览器
2. Ctrl+Shift+I打开Chrome的开发者工具
3. 切换到Network面板
4. 选中Doc标签
5. 刷新页面，分析客户端与服务器的通信过程

## 1.4 服务器对外提供了哪些资源

### 1.4.1 列举网页中常见的资源

文字内容、Image图片、Audio音频、Video视频

思考：网页中的**数据**是不是资源？

### 1.4.2 数据也是资源

**网页中的数据，也是服务器对外提供的一种资源。**例如股票数据、各行业排行榜等。

### 1.4.3 数据是网页的灵魂

- HTML是网页的**骨架**
- CSS是网页的**颜值**
- JavaScript是网页的**行为**
- 数据，则是网页的**灵魂**

**骨架、颜值、行为皆为数据服务。数据，在网页中无处不在。**

### 1.4.4 网页中如何请求数据

数据，也是服务器对外提供的一种资源。只要是资源，必然要通过请求-处理-响应的方式进行获取。

（1）请求数据资源  （2）服务器处理这次数据请求  （3）把数据响应给客户端

如果要在网页中请求服务器上的数据资源，则需要用到**XMLHttpRequest对象**。

XMLHttpRequest（简称xhr）是浏览器提供的js成员，通过它，可以请求服务器上的数据资源。

最简单的用法 **var  xhrObj = new XMLHttpRequest()**

### 1.4.5 资源的请求方式

客户端请求服务器时，**请求的方式**有很多种，最常见的两种请求方式分别为**get**和**post**请求。

- **get请求**通常用于**获取服务端资源**(向服务器要资源)

  例如，根据URL地址，从服务器获取HTML文件、css文件、js文件、图片文件、数据资源等

- **post请求**通常用于**向服务器提交数据**(往服务器发送资源)

  例如，登录时向服务器**提交的登录信息**、注册时向服务器**提交的注册信息**、添加用户时向服务器**提交的用户 信息**等各种**数据提交操作**

## 1.5 了解Ajax

### 1.5.1 什么是Ajax

Ajax的全称是Asynchronous Javascript And XML（异步JavaScript和XML）。

通俗的理解：在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式，就是Ajax。

### 1.5.2 为什么要学Ajax

之前所学的技术，只能把网页做的更美观漂亮，或添加一些动画效果，但是，**Ajax**能让我们轻松实现**网页与服务器之间的数据交互**。

用户 ----(交互)----网页(数据载体)----（Ajax数据传输）----服务器

### 1.5.3 Ajax的典型应用场景

用户名检测：注册用户时，通过ajax的形式，动态**检测用户名是否被占用**

搜索提示：当输入搜索关键字时，通过ajax的形式，动态**加载搜索提示列表**

数据分页显示：当点击页码值的时候，通过ajax的形式，**根据页码值动态刷新表格的数据**

数据的增删改查：数据的添加、删除、修改、查询操作，都需要通过ajax的形式，来实现数据的交互

## 1.6 jQuery中的Ajax

### 1.6.1 了解jQuery中的Ajax

浏览器中提供的**XMLHttpRequest用法比较复杂**，所以jQuery对XMLHttpRequest进行了封装，提供了一系列Ajax相关的函数，极大地**降低了Ajax的使用难度**。

jQuery中发起Ajax请求最常用的三个方法如下：

- $.get()
- $.post()
- $.ajax()

### 1.6.2 $.get()函数的语法

jQuery中$.get()函数的功能单一，专门用来发起get请求，从而将服务器上的资源请求到客户端来进行使用。

$.get()函数的语法如下：

```js
$.get(url,[data],[callback])
```

其中，三个参数各自代表的含义如下：

| 参数名   | 参数类型   | 是否必选 | 说明                                           |
| -------- | ---------- | -------- | ---------------------------------------------- |
| **url**  | **string** | **是**   | 要请求的**资源地址**                           |
| data     | object     | 否       | 请求资源期间要**携带的参数**(要发送到服务器的) |
| callback | function   | 否       | 请求成功时的**回调函数**                       |

#### 1.6.2.1 $.get()发起不带参数的请求

使用$.get()函数发起不带参数的请求时，直接提供请求的URL地址和请求成功之后的回调函数即可。示例代码如下：

```js
$.get('http://www.liulongbin.top:3006/api/getbooks',function(res) {
    console.log(res);  // 这里的res是服务器返回的数据
})
```

#### 1.6.2.2 $.get()发起带参数的请求

使用$.get()函数发起带参数的请求时，示例代码如下：

```js
$.get('http://www.liulongbin.top:3006/api/getbooks',{id: 1},function(res) {
    console.log(res);
})
```

### 1.6.3 $.post()函数的语法

jQuery中$.post()函数的功能单一，专门用来发起post请求，从而向服务器提交数据。

$.post()函数的语法如下：

```js
$.post(url,[data],[callback])
```

其中，三个参数各自代表的含义如下：

| 参数名   | 参数类型   | 是否必选 | 说明                         |
| -------- | ---------- | -------- | ---------------------------- |
| **url**  | **string** | **是**   | **提交数据的地址**           |
| data     | object     | 否       | **要提交的数据**             |
| callback | function   | 否       | 数据提交成功时的**回调函数** |

使用$.post()向服务器提交数据的示例代码如下：

```js
$.post(‘http://www.liulongbin.top:3006/api/addbook’,   // 请求的url地址
       {bookname: '水浒传', author: '施耐庵', publisher: '上海图书出版社'}, // 提交的数据
    	function(res) {  // 回调函数
       console.log(res);
       })
```

### 1.6.4 $.ajax()函数的语法

相比于$.get()和$.post()函数，jQuery中提供的$.ajax()函数，是一个功能比较综合的函数，它允许我们对Ajax请求进行更详细的配置。

$.ajax()函数的基本语法如下：

```js
$.ajax({
    type: '',  // 请求的方式，例如GET或者POST
    url: '',   // 请求的URL地址
    data: { }, // 这些请求要携带的数据
    success: function(res) { }  // 请求成功之后的回调函数
})
```

#### 1.6.4.1 使用$.ajax()发起GET请求

使用$.ajax()发起GET请求时，只需要将**type属性**的值设置为‘**GET**’即可：

```js
$.ajax({
    type: 'GET',
    url: 'http://www.liulongbin.top:3006/api/getbooks', // 请求的URL地址
    data: {id: 1},
    success: function(res) {
        console.log(res);
    }
})
```

#### 1.6.4.2 使用$.ajax()发起POST请求

使用$.ajax()发起POST请求时，只需将type属性的值设置为‘POST’即可：

```js
$.ajax({
    type: 'POST',
    url: 'http://www.liulongbin.top:3006/api/addbook',
    data: {
        bookname: '水浒传',
        author: '施耐庵',
        publisher: '上海图书出版社'
    },
    success: function(res) {
        console.log(res);
    }
})
```

## 1.7 接口

### 1.7.1 接口的概念

使用Ajax请求数据时，**被请求的URL地址**，就叫做**数据接口**（简称**接口**）。同时，每个接口必须有**请求方式**。

例如：

http://www.liulongbin.top:3006/api/getbooks   获取图书列表的接口(GET请求)

http://www.liulongbin.top:3006/api/addbook    添加图书的接口(POST请求)

### 1.7.2 分析接口的请求过程

1. 通过GET方式请求接口的过程

   用户与网页进行交互，希望从服务器获取数据。ajax向服务器发起GET数据请求，服务器处理请求，响应GET请求到客户端，ajax就拿到服务器响应的结果，将数据填充到页面上呈现给用户。

2. 通过POST方式请求接口的过程

   用户与网页进行交互，希望向服务器提交数据。ajax向服务器发起POST数据请求，服务器处理请求，响应POST请求，ajax就拿到服务器响应的结果再呈现给用户。

### 1.7.3 接口测试工具

1. 什么是接口测试工具

   为了验证接口能否被正常访问，我们尝尝需要使用接口测试工具，来对数据接口进行检测。

   好处：接口测试工具能让我们在不写任何代码的情况下，对接口进行调用和测试。

2. 下载并安装PostMan

   访问PostMan的官网下载网址http://www.getpostman.com/downloads/  ，下载所需的安装程序后，直接安装即可。

3. 了解PostMan界面的组成部分

   PostMan界面的组成部分，从上到下，从左到右，分别是：

   - 菜单栏
   - 工具栏
   - 左侧历史记录与集合面板
   - 请求页签
   - 请求地址区域
   - 请求参数区域
   - 响应结果区域
   - 状态栏

### 1.7.4 使用PostMan测试GET接口

步骤：

1. 选择请求的方式
2. 填写请求的URL地址
3. 填写请求的参数(可选)
4. 点击Send按钮发起GET请求
5. 查看服务器响应的结果

### 1.7.5 使用PostMan测试POST接口

步骤：

1. 选择请求的方式
2. 填写请求的URL地址
3. 选择Body面板并**勾选数据格式**(x-www-form-urlencoded)
4. 填写要发送到服务器的数据
5. 点击Send按钮发起POST请求
6. 查看服务器响应的结果

### 1.7.6 接口文档

1. 什么是接口文档

   接口文档，顾名思义就是**接口的说明文档**，**它是我们调用接口的依据**。好的接口文档包含了对**接口URL**，**参数**以及**输出内容**的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用。

2. 接口文档的组成部分

   接口文档可以包含很多信息，也可以按需进行精简，不过，一个合格的接口文档，应该包含以下6项内容，从而为接口的调用提供依据：

   （1）**接口名称**：用来标识各个接口的简单说明，如**登录接口**，**获取图书列表接口**等。

   （2）**接口URL**：接口的调用地址。

   （3）**调用方式**：接口的调用方式，如GET或POST。

   （4）**参数格式**：接口需要传递的参数，每个参数必须包含**参数名称、参数类型、是否必选、参数说明**这4项内容。

   （5）**响应格式**：接口的返回值的详细描述，一般包含**数据名称、数据类型、说明**这3项内容。

   （6）返回示例(可选)：通过对象的形式，例举服务器返回数据的结构。

3. 接口文档示例

   - **图书列表**

   - **接口URL**：http://www.liulongbin.top:3006/api/getbooks

   - **调用方式**：GET

   - **参数格式**

     | 参数名称  | 参数类型 | 是否必选 | 参数说明 |
     | --------- | -------- | -------- | -------- |
     | id        | Number   | 否       | 图书id   |
     | bookname  | String   | 否       | 图书名称 |
     | author    | String   | 否       | 作者     |
     | publisher | String   | 否       | 出版社   |

   - **响应格式**

     | 数据名称   | 数据类型 | 说明                   |
     | ---------- | -------- | ---------------------- |
     | status     | Number   | 200成功；500失败       |
     | msg        | String   | 对status字段的详细描述 |
     | data       | Array    | 图书列表               |
     | +id        | Number   | 图书id                 |
     | +bookname  | String   | 图书名称               |
     | +author    | String   | 作者                   |
     | +publisher | String   | 出版社                 |

   - **返回示例**

     ```js
     {
         "status": 200,
         "msg": "获取图书列表成功",
         "data": [
             {"id": 1, "bookname": "西游记", "author": "吴承恩", "publisher": "北京图书出版社"},
             {"id": 2, "bookname": "红楼梦", "author": "曹雪芹", "publisher": "上海图书出版社"},
             {"id": 3, "bookname": "三国演义", "author": "罗贯中", "publisher": "北京图书出版社"}
         ]
     }
     ```

## 1.8 案例-图书管理

### 1.8.1 渲染UI结构

### 1.8.2 案例用到的库和插件

用到的css库bootstrap.css；用到的javascript库jquery.js;  用到的vs code插件Bootstrap 3 Snippets

### 1.8.3 渲染图书列表(核心代码)

```js
function getBookList() {
    // 1. 发送ajax请求获取图书列表数据
    $.get('http://www.liulongbin.top:3006/api/getbooks',function(res) {
        // 2. 获取列表数据是否成功
        if (res.status !== 200) return alert('获取图书列表失败！')
        // 3. 渲染页面结构
        var rows = []
        $.each(res.data,function(i,item) {
            // 4. 循环拼接字符串
            rows.push('<tr><td>'+item.id+'</td><td>'+item.bookname+'</td><td>'+item.author+'</td><td>'+item.publisher+'</td><td><a href="javascript:;">删除</a></td></tr>')  // href="javascript:;"是为了防止a链接的跳转
        })
        $('#bookBody').empty().append(rows.join(''))  // 渲染表格结构
    })
}
```

## 1.9 案例-聊天机器人

### 1.9.1 演示案例要完成的效果

实现步骤：

1. 梳理案例的代码结构

   （1）梳理页面的UI结构

   （2）将业务代码抽离到chat.js中

   （3）了解resetui()函数的作用(向聊天区域追加内容后，调用resetui()这个函数，就能让滚动条重置到最底部)

2. 将用户输入的内容渲染到聊天窗口

   ```js
   // 为发送按钮绑定点击事件处理函数
   $('#btnSend').on('click',function() {
       var text = $('#ipt').val().trim();  // 获取用户输入的内容
       if(text.length<=0) {
           // 判断用户输入的内容是否为空
           return $('#ipt').val();
       }
       // 将用户输入的内容显示到聊天窗口中
       $('#talk_list').append('<li class="right_word"><img src="img/person02.png" /> <span>'+text+'</span></li>');
       resetui();  // 重置滚动条的位置
       $('#ipt').val('');  // 清空输入框的内容
   })
   ```

3. 发起请求获取聊天消息

   ```js
   function getMsg(text) {
       $.ajax({
           method: 'GET',
           url: 'http://ajax.frontend.itheima.net:3006/api/robot',
           data: {
               spoken: text
           },
           success: function(res) {
               if (res.message === 'success') {
                   var msg = res.data.info.text
                   $('#talk_list').append('<li class="left_word"><img src="img/person01.ong"/><span>'+msg+'</span></li>')
                   resetui();
               }
           }
       })
   }
   ```

4. 将机器人的聊天内容转为语音

   通过< audio >播放语音

   ```js
   function getVoice(text) {
       $.ajax({
           method: 'GET',
           url: 'http://ajax.frontend.itheima.net:3006/api/synthesize',
           data: {
               text: text
           },
           success: function(res) {
               // 如果请求成功，则res.voiceUrl是服务器返回的音频的URL地址
               if (res.status === 200) {
                   $('#voice').attr('src',res.voiceUrl);
               }
           }
       })
   }
   ```

5. 通过<audio>播放语音

   ```html
   <audio src="" id="voice" autoplay style="display: none;"></audio>
   ```

6. 使用回车键发送消息

   ```js
   // 让文本输入框响应回车事件后，提交信息
   $('#ipt').on('keyup',function(e) {
       // e.keyCode 可以获取到当前按键的编码
       if (e.keyCode === 13) {
           // 调用按钮元素的click函数，可以通过编程的形式触发按钮的点击事件
           $('#btnSend').click()
       }
   })
   ```

   

# 2. form表单与模板引擎

目标：

- 能够说出form表单的常见属性
- 能够知道如何阻止表单的默认提交行为
- 能够知道如何使用jQuery快速获取表单数据
- 能够知道如何安装和使用模板引擎
- 能够知道模板引擎的实现原理

## 2.1 form表单的基本使用

### 2.1.1 什么是表单

表单在网页中主要负责**数据采集功能**。HTML中的<form>标签，就是用于采集用户输入的信息，并通过<form>标签的提交操作，把采集到的信息提交到服务器端进行处理。

```html
<form>
    <input type="text", name="email_or_mobile" />
    <input type="password" name="password" />
    <input type="checkbox" name="remeber_me" checked />
    <button type="submit">提交</button>
</form>
```

### 2.1.2 表单的组成部分

表单由三个基本部分组成：

- 表单标签
- 表单域
- 表单按钮< button type="submit">< /button>

常用的表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。

表单域的作用是采集用户信息，载体是form表单标签。

### 2.1.3 < form >标签的属性

< form >标签用来采集数据，< form >标签的属性则是用来规定**如何把采集到的数据发送到服务器**。

| 属性    | 值                                                           | 描述                                         |
| ------- | ------------------------------------------------------------ | -------------------------------------------- |
| action  | URL地址                                                      | 规定当提交表单时，**向何处发送表单数据**     |
| method  | get或post                                                    | 规定**以何种方式**把表单数据提交到action URL |
| enctype | application/x-www-form-urlencoded multipart/form-data  text/plain | 规定在**发送表单数据之前如何对数据进行编码** |
| target  | _blank    _self   _parent   _top   framename                 | 规定**在何处打开action URL**                 |

1. action

   action属性的值应该是后端提供的一个URL地址，这个URL地址专门负责接收表单提交过来的数据。

   当< form >表单在未指定action属性值的情况下，action的默认值为当前页面的URL地址。

   **注意：**当提交表单后，页面会立即跳转到action属性指定的URL地址，同时将提交的表单数据以字符串的形式放到URL地址的后面。

2. target

   它的可选值有5个，默认情况下，target的值是_self，表示在相同的框架中打开action URL。

   | 值         | 描述                         |
   | ---------- | ---------------------------- |
   | **_blank** | **在新窗口中打开**           |
   | **_self**  | **默认。在相同的框架中打开** |
   | _parent    | 在父框架集中打开(很少用)     |
   | _top       | 在整个窗口中打开(很少用)     |
   | framename  | 在指定的框架中打开(很少用)   |

3. method

   method的可选值有两个，分别是get和post。

   默认情况下，method的值为get，表示通过URL地址的形式，把表单数据提交到action URL。

   注意：get方式适合用来提交少量的、简单的数据。(不是特别的隐秘)

   ​			post方式适合用来提交**大量的、复杂的**、或包含**文件上传**的数据。安全性有保障。

   ​			在实际开发中，< form >表单的post提交方式用的最多，很少用get。例如登录、注册、添加数据等表单操作，都需要使用post方式来提交表单。

4. enctype

   它的可选值有三个，默认情况下，enctype的值为application/x-www-form-urlencoded，表示在发送前编码所有的字符。

   | 值                                | 描述                                                       |
   | --------------------------------- | ---------------------------------------------------------- |
   | application/x-www-form-urlencoded | 在发送前编码所有字符(默认)                                 |
   | multipart/form-data               | 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值 |
   | text/plain                        | 空格转换为“+”加号，但不对特殊字符编码。(很少用)            |

   **注意：**在涉及到**文件上传**操作时，**必须**将enctype的值设置为**multipart/form-data**

   ​			如果表单的提交不涉及到文件上传操作，则直接将ectype的值设置为application/x-www-form-urlencoded即可！

### 2.1.4 表单的同步提交及缺点

1. 什么是表单的同步提交

   通过点击submit按钮，触发表单提交的操作，从而使页面跳转到action URL的行为，叫做表单的同步提交。

2. 表单同步提交的缺点

   （1）< form >表单同步提交后，整个页面会发生跳转，**跳转到action URL所指向的地址**，用户体验很差。

   （2）< form >表单同步提交后，**页面之前的状态和数据会丢失**。

3. 如何解决表单同步提交的缺点

   解决方案：**表单只负责采集数据，Ajax负责将数据提交到服务器**。

## 2.2 通过Ajax提交表单数据

### 2.2.1 监听表单提交事件

在jQuery中，可以使用如下两种方式，监听到表单的提交事件：

```js
$('#form1').submit(function(e) {
    alert('监听到了表单的提交事件');
})

$('#form1').on('submit',function(e) {
    alert('监听到了表单的提交事件');
})
```

### 2.2.2 阻止表单默认提交行为

当监听到表单的提交事件以后，可以调用事件对象的event.preventDefault()函数，来阻止表单的提交和页面的跳转，示例代码如下：

```js
$('#form1').submit(function(e) {
    // 阻止表单的提交和页面的跳转
    e.preventDefault();
})

$('#form1').on('submit',function(e) {
    // 阻止表单的提交和页面的跳转
    e.preventDefault();
})
```

### 2.2.3 快速获取表单中的数据

1. serialize()函数

   为了简化表单中数据的获取操作，jQuery提供了serialize()函数，其语法格式如下：

   ```js
   $(selector).serialize()
   ```

   serialize()函数的好处：**可以一次性获取到表单中的所有的数据**。

2. serialize()函数示例

   ```html
   <form id="form1">
       <input type="text" name="username" />   // name属性一定要有，不可以省略
       <input type="password" name="password" />
       <button type="submit">提交</button>
   </form>
   ```

   ```js
   $('#form1').serialize();
   // 调用的结果：
   // username=用户名的值&password=密码的值
   ```

   注意：在使用serialize()函数快速获取表单数据时，**必须为每个表单元素添加name属性！**

## 2.3 案例-评论列表

```js
function getCmtList() {
    $.get('http://www.liulongbin.top:3006/api/cmtlist',function(res) {
        if (res.status!==200) {
            return alert('获取评论列表失败');
        }
        var rows=[];
        $.each(res.data,function(i,item) {
            // 循环拼接字符串
            rows.push('<li class="list-group-item>'+item.content+'<span class="badge cmt-date">评论时间：'+item.time+'</span><span class="badge cmt-person">评论人：'+item.username+'</span></li>')
        })
        $('#cmt-list').empty().append(rows.join(''))  // 渲染列表的UI结构
    })
}
```

注意：如何将表单的内容清空，首先获取到表单的jQuery对象，然后调用[0]，将jQuery对象转换为一个原生的Dom对象，此时就可以调用reset()方法，这个方法是用来重置表单的。

## 2.4 模板引擎的基本概念

### 2.4.1 渲染UI结构时遇到的问题

```js
var rows=[];
        $.each(res.data,function(i,item) {
            // 循环拼接字符串
            rows.push('<li class="list-group-item>'+item.content+'<span class="badge cmt-date">评论时间：'+item.time+'</span><span class="badge cmt-person">评论人：'+item.username+'</span></li>')
        })
        $('#cmt-list').empty().append(rows.join(''))  // 渲染列表的UI结构
```

上述代码是通过**字符串拼接**的形式，来渲染UI结构。

如果UI结构比较复杂，则拼接字符串的时候需要格外注意**引号之间的嵌套**。且一旦需求发生变化，**修改起来也非常麻烦**。

### 2.4.2 什么是模板引擎

模板引擎，顾名思义，它可以根据程序员指定的**模板结构**和**数据**，自动生成一个完整的HTML页面。

数据+模板结构→通过模板引擎→HTML页面

### 2.4.3 模板引擎的好处

（1）减少了字符串的拼接操作

（2）使代码结构更清晰

（3）使代码更易于阅读与维护

## 2.5 art-template模板引擎

### 2.5.1 art-template简介

art-template是一个简约、超快的模板引擎。中文的官网首页为http://aui.github.io/art-template/zh-cn/index.html

### 2.5.2 art-template的安装

在浏览器中访问http://aui.github.io/art-template/zh-cn/docs/installation.html页面，找到下载链接后，鼠标右键，选择“链接另存为”，将art-template下载到本地，然后，通过< script >标签加载到网页上进行使用。

### 2.5.3 art-template模板引擎的基本使用

1. 使用传统方式渲染UI结构

   ```html
   <div id="title"></div>
     <div>姓名：<span id="name"></span></div>
     <div>年龄：<span id="age"></span></div>
     <div>会员：<span id="isVIP"></span></div>
     <div>注册时间：<span id="regTime"></span></div>
     <div>爱好：
       <ul id="hobby">
         <li>爱好1</li>
         <li>爱好2</li>
       </ul>
     </div>
   ```

   ```js
   <script>
     $(function () {
       var data = {
         title: '<h3>用户信息</h3>',
         name: 'zs',
         age: 20,
         isVIP: true,
         regTime: new Date(),
         hobby: ['吃饭', '睡觉', '打豆豆']
       }
       $('#title').html(data.title);
       $('#name').html(data.name);
       $('#age').html(data.age);
       $('#isVIP').html(data.isVIP);
       $('#regTime').html(data.regTime);
       var rows = [];
       $.each(data.hobby, function (i, item) {
         rows.push('<li>' + item + '</li>')
       })
       $('#hobby').html(rows.join(''));
     })
   </script>
   ```

2. art-template的使用步骤

   （1）导入art-template

   （2）定义数据

   （3）定义模板

   （4）调用template函数

   （5）渲染HTML结构

### 2.5.4 art-template标准语法

1. 什么是标准语法

   art-template提供了**{{ }}**这种语法，在**{{ }}**内可以进行**变量输出**，或**循环数组**等操作，这种{{ }}语法在art-template中被称为标准语法。

2. 标准语法-输出

   ```js
   {{value}}
   {{obj.key}}
   {{obj['key']}}
   {{a ? b : c}}
   {{a || b}}
   {{ a + b}}
   ```

   在{{ }}语法中，可以进行**变量**的输出、**对象属性**的输出、**三元表达式**输出、**逻辑或**输出、**加减乘除等表达式**输出。

3. 标准语法-原文输出

   ```js
   {{@ value}}
   ```

   如果要输出的value值中，包含了HTML标签结构，则需要使用原文输出语法，才能保证HTML标签被正常渲染。

4. 标准语法-条件输出

   如果要实现条件输出，则可以在{{ }}中使用**if...else if.../if**的方式，进行按需输出。

   ```js
   {{if value}}按需输出内容{{/if}}
   {{if v1}} 按需输出的内容{{else if v2}} 按需输出的内容{{/if}}
   ```

5. 标准语法-循环输出

   如果要实现循环输出，则可以在{{ }}内，通过each语法循环数组，当前循环的索引使用$index进行访问，当前循环项使用$value进行访问。

   ```html
   {{each arr}}
   	{{$index}}  {{$value}}
   {{/each}}
   ```

6. 标准语法-过滤器

   自来水→净水器→纯净水

   需处理的值→(参数)→过滤器函数→(返回值)→输出新值

   过滤器的本质，就是一个function处理函数。

   ```js
   {{value | fliterName}}
   ```

   过滤器语法类似**管道操作符**，它的上一个输出作为下一个输入。

   定义过滤器的基本语法如下：

   ```js
   template.defaults.imports.filterName = function(value) {return处理的结果}
   ```

   ```html
   <div>
       注册时间：{{regTime | dateFormat}}
   </div>
   ```

   定义一个格式化时间的过滤器dateFormat如下：

   ```js
   template.defaults.imports.dateFormat = function(date) {
       var y = date.getFullYear();
       var m = date.getMonth() + 1;
       var d = date.getDate();
       return y + '-' + m + '-' + d;  // 注意，过滤器最后一定要return一个值
   }
   ```

### 2.5.5 案例--新闻列表

1. 实现步骤

   （1）获取新闻数据

   ```js
   function getNewsList () {
       $.get("http://www.liulongbin.top:3006/api/news", function (res) {
         if (res.status !== 200) {
           return alert("获取新闻列表失败")
         }
         for (var i = 0; i < res.data.length; i++) {
           // 把每一项的tags属性。从字符串改造成字符串的数组
           res.data[i].tags = res.data[i].tags.split(",")
         }
         var htmlstr = template("tpl-news", res)
         $("#news-list").html(htmlstr)
       })
     }
   ```

   （2）定义template模板

   （3）编译模板

   ```html
   <script type="text/html" id="tpl-news">
       {{each data}}
       <div class="news-item">
         <img class="thumb" src="{{'http://www.liulongbin.top:3006'+$value.img}}">
         <div class="right-box">
           <h1 class="title">{{$value.title}}</h1>
           <div class="tags">
             {{each $value.tags}}
             <span>{{$value}}</span>
             {{/each}}
           </div>
           <div class="footer">
             <div>
               <span>{{$value.source}}</span>&nbsp;&nbsp;
               <span>{{$value.time | dateFormat}}</span>
             </div>
             <span>评论数：{{$value.cmtcount}}</span>
           </div>
         </div>
       </div>
       {{/each}}   
     </script>
   ```

   

   （4）定义时间过滤器

   ```js
   // 定义格式化时间的过滤器
     template.defaults.imports.dateFormat = function (dtstr) {
       var dt = new Date(dtstr)
   
       var y = dt.getFullYear()
       var m = padZero(dt.getMonth() + 1)
       var d = padZero(dt.getDate())
   
       var hh = padZero(dt.getHours())
       var mm = padZero(dt.getMinutes())
       var ss = padZero(dt.getSeconds())
   
       return y + "-" + m + "-" + d + " " + hh + ":" + mm + ":" + ss
     }
   ```

   （5）定义补零函数

   ```js
   // 给时间补充0的函数
     function padZero (n) {
       if (n < 10) {
         return "0" + n
       } else {
         return n
       }
     }
   ```

## 2.6 模板引擎的实现原理

### 2.6.1 正则与字符串操作

1. 基本语法

   exec()函数用于**检索字符串**中的正则表达式的匹配。

   如果字符串中有匹配的值，**则返回该匹配值**，否则返回**null**。

   ```js
   RegExpObject.exec(string)
   ```

   实例代码如下：

   ```js
   var str = 'hello';
   var pattern = /o/;
   // 输出的结果["o", index: 4, input: "hello", groups: undefined]
   console.log(pattern.exec(str));
   ```

2. 分组

   正则表达式中( )包起来的内容表示一个分组，可以通过分组来**提取自己想要的内容**，实例代码如下：

   ```js
   var str = '<div>我是{{name}}</div>';
   var pattern = /{{([a-zA-Z]+)}};
   var patternResult = pattern.exec(str);
   console.log(patternResult);
   // 得到name相关的分组信息
   // ["{{name}}", "name", index: 7, input: "<div>我是{{name}}</div>", groups: undefined]
   // 前两项分别是匹配的内容，提取的内容
   ```

3. 字符串的replace函数

   replace()函数用于在字符串中**用一些字符替换另一些字符**，语法格式如下：

   ```js
   var result = '123456'.replace('123','abc');
   // 得到的 result 的值为字符串 'abc456'
   ```

   实例代码如下：

   ```js
   var str = '<div>我是{{name}}</div>';
   var pattern = /{{([a-zA-Z]+)}};
   var patternResult = pattern.exec(str);
   str = str.replace(patternResult[0], patternResult[1])// replace函数返回值为替换后的新字符串
   // 输出的内容是: <div>我是name</div>
   console.log(str);
   ```

4. 多次replace

   ```js
   var str = '<div>{{name}}今年{{ age }}岁了</div>';
   var pattern = /{{\s*([a-zA-Z]+)\s*}};
   
   var patternResult = pattern.exec(str);
   str = str.replace(patternResult[0], patternResult[1]);
   console.log(str);  // 输出 <div>name今年{{ age }}岁了</div>
   
   patternResult = pattern.exec(str);
   str = str.replace(patternResult[0], patternResult[1]);
   console.log(str);  // 输出 <div>name今年age岁了</div>
   
   patternResult = pattern.exec(str);
   console.log(patternResult);  // 输出 null
   ```

5. 使用while循环replace

   ```js
   var str = '<div>{{name}}今年{{ age }}岁了</div>';
   var pattern = /{{\s*([a-zA-Z]+)\s*}};
   
   var patternResult = null;
   while(patternResult = pattern.exec(str)) {
       str = str.replace(patternResult[0],patternResult[1])
   }
   console.log(str);  // 输出<div>name今年age岁了</div>
   ```

6. replace替换为真值

   下面几行是模板引擎的核心代码，先有数据data，再有模板str，要做的是一个替换的过程，调用字符串的替换函数，将正则提取到的内容替换为数据里面的值即可。

   ```js
   var data = {name: '张三', age: 20};
   var str = '<div>{{name}}今年{{ age }}岁了</div>';
   var pattern = /{{\s*([a-zA-Z]+)\s*}};
   
   var patternResult = null;
   while(patternResult = pattern.exec(str)) {
       str = str.replace(patternResult[0],data[patternResult[1]])
   }
   console.log(str);
   ```

### 2.6.2 实现简易的模板引擎

1. 实现步骤

   （1）定义模板结构

   ```js
   <script type="text/html" id="tpl-user">
       <div>姓名：{{name}}</div>
   	<div>年龄：{{ age }}</div>
   	<div>性别：{{  gender}}</div>
   	<div>住址：{{address  }}</div>
   </script>
   ```

   （2）预调用模板引擎

   ```js
   <script>
       // 定义数据
       var data = {name: 'zs', age: 28, gender: '男', address: '北京顺义马坡'};
   	
   	// 调用模板函数
   	var htmlStr = template('tpl-user',data);
   
   	// 渲染HTML结构
   	// document.getElementById('user-box').html(htmlStr);
   	document.getElementById('user-box').innerHTML = htmlStr;
   <script>
   ```

   （3）封装template函数

   ```js
   function template(id,data) {
       var str = document.getElementById(id).innerHTML;
       var pattern = /{{\s*([a-zA-Z]+)\s*}}/;
       
       var patternResult = null;
       while(patternResult = pattern.exec(str)) {
           str = str.replace(patternResult[0],data[patternResult[1]]);
       }
       return str;
   }
   ```

   （4）导入并使用自定义的模板引擎

   ```js
   <script src="./js/template.js"></script>
   ```



# 3. Ajax加强

目标：

- 能够知道如何使用XMLHttpRequest发起Ajax请求
- 能够知道如何封装自己的Ajax函数
- 能够使用XMLHttpRequest Level2中提供的新特性
- 能够知道jQuery中如何实现文件上传与loading效果
- 能够知道如何使用axios发起Ajax请求

## 3.1 XMLHttpRequest的基本使用

### 3.1.1 什么是XMLHttpRequest的基本使用

XMLHttpRequest（简称xhr），是浏览器提供的Javascript对象，通过它，可以**请求服务器上的数据资源**。之前所学的jQuery中的Ajax函数，就是基于xhr对象封装出来的。

### 3.1.2 使用xhr发起GET请求

步骤：

（1）创建xhr对象

（2）调用xhr.open()函数   来创建一个请求

（3）调用xhr.send()函数    来发起这个请求

（4）监听xhr.onreadystatechange事件    如果请求成功就可拿到服务器响应的数据

```js
// 1. 创建 XHR 对象
var xhr = new XMLHttpRequest();
// 2. 调用open函数，指定请求方式与URL地址
xhr.open('GET','http://liulongbin.top:3006/api/getbooks');
// 3. 调用send函数，发起Ajax请求
xhr.send();
// 4. 监听onreadystatechange事件
xhr.onreadystatechange = function() {
    // 4.1 监听xhr对象的请求状态readyState；与服务器响应的状态status
    if (xhr.readyState === 4 && xhr.status === 200) {
        // 4.2 打印服务器响应回来的数据
        console.log(xhr.responseText);
    }
}
```

### 3.1.3 了解xhr对象的readyState属性

XMLHttpRequest对象的readyState属性，用来表示**当前Ajax请求所处的状态**。每个Ajax请求必然处于以下状态中的一个：

| 值    | 状态             | 描述                                                         |
| ----- | ---------------- | ------------------------------------------------------------ |
| 0     | UNSET            | XMLHttpRequest对象已被创建，但尚未调用open方法。             |
| 1     | OPEND            | open()方法已被调用。                                         |
| 2     | HEADERS_RECEIVED | send()方法已被调用，响应头也已经被接收。                     |
| 3     | LOADING          | 数据接收中，此时response属性中已经包含部分数据。             |
| **4** | **DONE**         | **Ajax请求完成**，这意味着数据传输已经彻底**完成**或**失败**。 |

### 3.1.4 使用xhr发起带参数的GET请求

使用xhr对象发起带参数的GET请求时，只需在调用xhr.open期间，为URL地址指定参数即可：

```js
xhr.open('GET','http://www.liulongbin.top:3006/api/getbooks?id=1');
```

这种在URL地址后面拼接的参数，叫做**查询字符串**。

### 3.1.5 什么是查询字符串

1. 定义：查询字符串(URL参数)是指在URL的末尾加上用于向服务器发送信息的字符串(变量)。

格式：将英文?放在URL的末尾，然后再加上 参数 = 值，想加上多个参数的话，使用&符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到URL中。

```js
// 不带参数的URL地址
http://www.liulongbin.top:3006/api/getbooks
// 带一个参数的URL地址
http://www.liulongbin.top:3006/api/getbooks?id=1
// 带两个参数的URL地址
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记
```

2. GET请求携带参数的本质

   无论使用$.ajax()，还是使用$.get()，又或者直接使用xhr对象发起GET请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到URL地址的后面，发送到服务器的。

   ```js
   $.get('url',{name: 'zs', age: 20}, function() {})
   // 等价于
   $.get('url?name=zs&age=20',function() {})
   
   $.ajax({method: 'GET', url: 'url', data: {name: 'zs', age: 20}, success: function() {}})
   // 等价于
   $.ajax({method: 'GET', url: 'url?name=zs&age=20', success: function() {}})
   ```

### 3.1.6 URL编码与解码

1. 什么是URL编码

   URL地址中，只允许出现英文相关的字母。标点符号、数字，因此，在URL地址中不允许出现中文字符。

   如果URL中需要包含中文这样的字符，则必须对中文字符进行**编码**(转义)。

   **URL编码的原则**：使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。

   URL编码原则的通俗理解：使用**英文字符**去表示**非英文字符**。

   ```js
   http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记
   // 经过URL编码之后，URL地址变成了如下格式：
   http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0中文字符如果要使用英文字符来表示的话，一定是三组百分号。
   ```
   
2. 如何对URL进行编码与解码

   浏览器提供了URL编码与解码的API，分别是：

   - encodeURI()  编码的函数
   - decodeURI()  解码的函数

   ```js
   encodeURI('黑马程序员')
   // 输出字符串 %E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98
   decodeURI('%E9%BB%91%E9%A9%AC')
   // 输出字符串  黑马
   ```

3. URL编码的注意事项

   由于浏览器会自动对URL地址进行编码操作，因此，大多数情况下，程序员不需要关心URL地址的编码与解码操作。

   更多关于URL编码的知识，请参考如下博客：

   https://blog.csdn.net/Lxd_0111/article/details/78028889

### 3.1.7 使用xhr发起POST请求

步骤：

（1）创建xhr对象

（2）调用xhr.open()函数

（3）**设置Content-Type属性**(固定写法)

（4）调用xhr.send()函数，**同时指定要发送的数据**

（5）监听xhr.onreadystatechange事件

```js
// 1. 创建xhr对象
var xhr = new XMLHttpRequest()
// 2. 调用open()
xhr.open('POST','http://www.liulongbin.top:3006/api/addbook')
// 3. 设置 Content-type属性(固定写法)
xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')
// 4. 调用send()，同时将数据以查询字符串的形式，提交给服务器
xhr.send('bookname=水浒传$author=施耐庵$publisher=天津出版社')
// 5. 监听 onreadystatechange 事件
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText)
    }
}
```

## 3.2 数据交换格式

### 3.2.1 什么是数据交换格式

数据交换格式，就是**服务器端**与**客户端**之间进行**数据传输与交换的格式**。

前端领域，经常提及的两种数据交换格式分别是**XML**和**JSON**。其中XML用的非常少，所以，我们重点要学习的数据交换格式就是JSON。

### 3.2.2 XML

1. 什么是XML

   XML的英文全称是EXtensible Markup Language，即可扩展标记语言。因此，XML和HTML类似，也是一种标记语言。

   HTML

   ```html
   <!DOCTYPE html>
   <html>
       <head>
           <title>Document</title>
       </head>
       <body></body>
   </html>
   ```

   XML

   ```xml
   <note>
   	<to>ls</to>
       <from>zs</from>
       <heading>通知</heading>
       <body>晚上开会</body>
   </note>
   ```

2. XML和HTML的区别

   XML和HTML虽然都是标记语言，但是，它们两者之间没有任何的关系。

   - HTML被设计用来描述网页上的**内容**，是网页内容的载体。
   - XML被设计用来**传输和存储数据**，是数据的载体。

   web服务器→(传输网页内容(HTML))→用户的电脑(客户端)

   web服务器→(传输数据(XML))→用户的电脑(客户端)

3. XML的缺点

   （1）XML格式臃肿，和数据无关的代码多，体积大，传输效率低

   （2）在Javascript中解析XML比较麻烦

### 3.2.3 什么是JSON

概念：JSON的英文全称是JavaScript Object Notation，即“JavaScript对象表示法”。简单来讲，**JSON就是JavaScript对象和数组的字符串表示法**，它使用文本表示一个JS对象或数组的信息，因此，JSON的本质就是字符串。

作用：JSON是一种**轻量级的文本数据交换格式**，在作用上类似于XML，专门用于存储和传输数据，但是JSON比XML**更小、更快、更易解析**。

现状：JSON是在2001年开始被推广和使用的数据格式，到现今为止，**JSON已经成为了主流的数据交换格式**。

### 3.2.4 JSON的两种结构

JSON就是用字符串来表示JavaScript的对象和数组，所以，JSON中包含**对象**和**数组**两种结构，通过这两种结构的**相互嵌套**，可以表示各种复杂的数据结构。

1. 对象结构

   对象结构在JSON中表示为{ }括起来的内容。数据结构为{ key: value, key: value,...}的键值对结构。其中，key必须是使用**英文的双引号包裹的字符串**，value的数据类型可以是**数字、字符串、布尔值、null、数组、对象**6种类型。

   找错：

   ```js
   {
       name: "zs",
       'age': 20,
       "gender": '男',
       "address": undefined,
       "hobby": ["吃饭", "睡觉", '打豆豆']
       say: function() { }
   }
   ```

   规范写法：

   ```js
   {
       "name": "zs",
       "age": 20,
       "gender": "男",
       "address": null,
       "hobby": ["吃饭", "睡觉", "打豆豆"]
   }
   ```

2. 数组结构

   数组结构在JSON中表示为[ ]括起来的内容。数据结构为[“java”, “javascript”, 30, true...]。数组中数据的类型可以是数字、字符串、布尔值、null、数组、对象6种类型。

   合法数组结构实例

   ```js
   [ "java", "python", "php" ]
   [ 100, 200, 300.5 ]
   [ ture, false, null ]
   [ {"name": "zs", "age": 20}, {"name": "ls", "age": 30} ]
   [ ["苹果", "榴莲", "椰子"], [4, 50, 5] ]
   ```

### 3.2.5 JSON语法的注意事项

（1）属性名必须使用双引号包裹

（2）字符串类型的值必须使用双引号包裹

（3）JSON中不允许使用单引号表示字符串

（4）JSON中不能写注释

（5）JSON的最外层必须是对象或数组格式

（6）不能使用undefined或函数作为JSON的值

JSON的作用：在计算机与网络之间存储和传输数据。

JSON的本质：用字符串来表示JavaScript对象数据或数组数据。

### 3.2.6 JSON和JS对象的关系

JSON是JS对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串。例如：

```js
// 这是一个对象
var obj = {a: 'Hello', b: 'World'}

// 这是一个JSON字符串，本质是一个字符串
var json = '{"a": "Hello", "b": "World"}'
```

### 3.2.7 JSON和JS对象的互转

要实现从JSON字符串转换为JS对象，使用JSON.parse()方法：

```js
var obj = JSON.parse('{"a": "Hello", "b": "World"}')
// 结果是 {a: 'Hello', b: 'World'}
```

要实现从JS对象转换为JSON字符串，使用JSON.stringify()方法：

```js
var json = JSON.stringify({a: 'Hello', b: 'World'})
// 结果是 '{"a": "Hello", "b": "World"}'
```

### 3.2.8 序列化和反序列化

把**数据对象转换为字符串**的过程，叫做**序列化**。例如：调用JSON.**stringify()**函数的操作，叫做JSON序列化。

把**字符串转换为数据对象**的过程，叫做**反序列化**，例如：调用JSON.**parse()**函数的操作，叫做JSON反序列化。

## 3.3 封装自己的Ajax函数

### 3.3.1 要实现的效果

```js
// 1. 导入自定义的ajax函数库
<script src="./itheima.js"></script>

<script>
    // 2. 调用自定义的itheima函数，发起Ajax数据请求
    itheima({
    method: '请求类型',
    url: '请求地址',
    data: { /* 请求参数对象 */},
    success: function(res) {
        // 成功的回调函数
        console.log(res);  // 打印数据
    }
})
</script>
```

### 3.3.2 定义options参数选项

itheima()函数是我们自定义的Ajax函数，它接收一个配置对象作为参数，配置对象中可以配置如下属性：

- method    请求的类型
- url             请求的URL地址
- data          请求携带的数据
- success     请求成功之后的回调函数

### 3.3.3 处理data数据

需要把data对象，转化成查询字符串的格式，从而提交给服务器，因此提前定义resolveData函数如下：

```js
// 处理 data 参数
// @param {data} 需要发送到服务器的数据
// @return {string} 返回拼接好的查询字符串 name=zs&age=10
function resolveData(data) {
    var arr = [];
    for (let k in data) {
        arr.push(k + '=' + data[k]);
    }
    return arr.join('&');
}
```

### 3.3.4 定义itheima函数

在itheima()函数中，需要创建xhr对象，并监听onreadystatechange事件：

```js
function resolveData(data) {
    var arr = [];
    for (let k in data) {
        arr.push(k + '=' + data[k]);
    }
    return arr.join('&');
}
function itheima(options) {
    var xhr = new XMLHttpRequest()
    // 拼接查询字符串
    var qs = resolveData(options.data)
    // 监听请求状态改变的事件
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200) {
            var result = JSON.parse(xhr.responseText)
            options.success(result)
        }
    }
}
```

### 3.3.5 判断请求的类型

不同的请求类型，对应xhr对象的不同操作，因此需要对请求的类型进行if...else...的判断：

```js
if (options.method.toUpperCase() === 'GET') {
    // 发起 GET 请求
    xhr.open(options.method, options.url + '?' + qs)
    xhr.send()
} else if (options.method.toUpperCase() === 'POST') {
    // 发起POST请求
    xhr.open(options.method,options.url)
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    xhr.send(qs)
}
```



## 3.4 XMLHttpRequest Level2的新特性

### 3.4.1 认识XMLHttpRequest Level2

1. 旧版XMLHttpRequest的缺点

   （1）只支持文本数据的传输，无法用来读取和上传文件

   （2）传送和接收数据时，没有进度信息，只能提示有没有完成

2. XMLHttpRequest Level2的新功能

   （1）可以设置HTTP请求的时限

   （2）可以使用FormData对象管理表单数据

   （3）可以上传文件

   （4）可以获得数据传输的进度信息

### 3.4.2 设置HTTP请求时限

有时，Ajax操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限：

```js
xhr.timeout = 3000  // 单位是毫秒 1秒 = 1000毫秒
```

上面的语句，将最长等待时间设为3000毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个timeout事件，用来指定回调函数：

```js
xhr.ontimeout = function(event) {
    alert('请求超时!')
}
```

### 3.4.3 FormData对象管理表单数据

Ajax操作往往用来提交表单数据。为了方便表单处理，HTML5新增了一个FormData对象，可以模拟表单操作：

```js
// 1. 新建 FormDate 对象
var fd = new FormData()
// 2. 为FormData 添加表单项
fd.append('uname','zs')
fd.append('upwd','123456')
// 3. 创建xhr对象
var xhr = new XMLHttpRequest()
// 4. 指定请求类型与URL地址
xhr.open('POST','http://www.liulongbin.top:3006/api/formdata')
// 5. 直接提交FormData对象，这与提交网页表单的效果，完全一样
xhr.send()
```

FormData对象也可以用来获取网页表单的值，示例代码如下：

```js
// 获取表单元素
var form = document.querySelector('#form1')
// 监听表单元素的submit事件
form.addEventListener('submit',function(e) {
    e.preventDefault()
    // 根据form表单创建FormData对象，会自动将表单数据填充到FormData对象中
    var fd = new FormData(form)
    var xhr = new XMLHttpRequest()
    xhr.open('POST','http://www.liulongbin.top:3006/api/formdata')
    xhr.send(fd)
    xhr.onreadystatechange = function() { }
})
```

### 3.4.4 上传文件

新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。

实现步骤：

（1）定义UI结构

```html
// 1. 文件选择框
<input type="file" id="file1" />
// 2. 上传按钮
<button id="btnUpload">上传文件</button>
<br />
// 3. 显示上传到服务器上的图片
<img src="" alt="" id="img" width='800' />
```

（2）验证是否选择了文件

```js
// 1. 获取上传文件的按钮
var btnUpload = document.querySelector('#btnUpload')
// 2. 为按钮添加click事件监听
btnUpload.addEventListener('click',function() {
    // 3. 获取到选择的文件列表
    var files = document.querySelector('#file1').files
    if(files.length <=0 ) {
        return alert('请选择要上传的文件!')
    }
    // ...后续业务逻辑
})
```

（3）向FormData中追加文件

```js
// 1. 创建FormData对象
var fd = new FormData()
// 2. 向FormData中追加文件
fd.append('avatar',files[0])
```

（4）使用xhr发起上传文件的请求

```js
// 1. 创建xhr对象
var xhr = new XMLHttpRequest()
// 2. 调用open函数，指定请求类型与URL地址。其中，请求类型必须为POST
xhr.open('POST','http://www.liulongbin.top:3006/api/upload/avatar')
// 3. 发起请求
xhr.send(fd)
```

（5）监听onreadystatechange事件

```js
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        var data = JSON.parse(xhr.responseText)
        if (data.status === 200) { // 上传文件成功
            // 将服务器返回的图片地址，设置为<img>标签的src属性
            document.querySelector('#img').src = 'http://www.liulongbin.top:3006' + data.url
        } else {  // 上传文件失败
            console.log(data.message)
        }
    }
}
```

### 3.4.5 显示文件上传进度

新版本的XMLHttpRequest对象中，可以通过监听xhr.upload.onprogress事件，来获取到文件的上传进度。

语法格式如下：

```js
// 创建xhr对象
var xhr = new XMLHttpRequest()
// 监听xhr.upload.onprogress事件
xhr.upload.onprogress = function(e) {
    // e.lengthComputable是一个布尔值，表示当前上传的资源是否具有可计算的长度
    if (e.lengthComputable) {
        // e.loaded 已传输的字节
        // e.total 需传输的总字节
        var percentComplete = Math.ceil((e.loaded / e.total) * 100) //ceil上取整
    }
}
```

1. 需要导入的库

2. 监听上传进度的事件

   ```js
   xhr.upload.onprogress = function(e) {
       if (e.lengthComputable) {
           // 1. 计算当前上传进度的百分比
           var percentComplete = Math.ceil((e.loaded / e.total) * 100)
           $('#percent')
           	// 2. 设置进度条的宽度
           	.attr('style','width:' + percentComplete + '%')
           	// 3. 显示当前的上传进度百分比
           	.html(percentComplete + '%')
       }
   }
   ```

3. 监听上传完成的事件

   ```js
   xhr.upload.onload = function() {
       $('#percent')
       	// 移除上传中的类样式
       	.removeClass()
       	// 添加上传完成的类样式
       	.addClass('progress-bar progress-bar-success')
   }
   ```

   

## 3.5 jQuery高级语法

### 3.5.1 jQuery实现文件上传

1. 定义结构

   ```js
   <script src="./lib/jquery.js"></script>
   <input type="file" id="file1">
   <button id="btnUpload">上传</button>
   ```

2. 验证是否选择了文件

   ```js
   $('#btnUpload').on('click',function() {
       // 1. 将jQuery对象转化为DOM对象，并获取选中的文件列表
       var files = $('#file1')[0].files
       // 2. 判断是否选择了文件
       if (files.length <= 0) {
           return alert('请选择图片后再上传!')
       }
   })
   ```

3. 向FormData中追加文件

   ```js
   // 向FormData中追加文件
   var fd = new FormaData()
   fd.append('avatar',files[0])
   ```

4. 使用jQuery发起上传文件的请求

   ```js
   $.ajax({
       method: 'POST',
       url: 'http://www.liulongbin.top:3006/api/upload/avatar',
       data: fd,
       // 不修改Content-Type属性，使用FormData默认的Content-Type值
       Content-Type: false,
       // 不对FormData中的数据进行url编码，而是将FormData数据原样发送到服务器
       processData: flase,
       success: function(res) {
       console.log(res)
   }
   })
   ```

### 3.5.2 jQuery实现loading效果

1. ajaxStart(callback)

   Ajax请求开始时，执行ajaxStart函数。可以在ajaxStart的callback中显示loading效果，示例代码如下：

   ```js
   // 自jQuery版本1.8起，该方法只能被附加到文档(document)
   $(document).ajaxStart(function() {
       $('#loading').show()
   })
   ```

   注意：$(document).ajaxStart()函数**会监听当前文档内所有的Ajax请求**。

2. ajax.Stop(callback)

   Ajax请求结束时，执行ajaxStop函数。可以在ajaxStop的callback中隐藏loading效果，实例代码如下：

   ```js
   // 自jQuery版本1.8起，该方法只能被附加到文档(document)
   $(document).ajaxStop(function() {
       $('#loading').hide()
   })
   ```


## 3.6 axios

### 3.6.1 什么是axios

Axios是专注于**网络数据请求**的库。

相比于原生的XMLHttpRequest对象，axios**简单易用**。

相比于jQuery，axios更加**轻量化**，只专注于网络数据请求。

### 3.6.2 axios发起GET请求

axios发起get请求的语法：

```js
axios.get('url',{ params: { /* 参数 */ } }).then(callback)
```

具体的请求示例如下：

```js
// 请求的URL地址
var url = 'http://www.liulongbin.top:3006/api/get';
// 请求的参数对象
var paramsObj = {name: 'zs', age: 20};
// 调用 axios.get() 发起GET请求
axios.get(url,{params: paramsObj}).then(function(res) {
    // res.data 是服务器返回的数据
    var result = res.data;
    console.log(res)
})
```

### 3.6.3 axios发起POST请求

axios发起post请求的语法：

```js
axios.post('url', { /* 参数 */ }).then(callback)
```

具体的请求示例如下：

```js
// 请求的URL地址
var url = 'http://www.liulongbin.top:3006/api/post';
// 要提交的数据
var dataObj = {location: '北京', address: '顺义'};
// 调用axios.post()发起POST请求
axios.post(url,dataObj).then(function(res) {
    // res.data是服务器返回的数据
    var result = res.data;
    console.log(result)
})
```

### 3.6.4 直接使用axios发起请求

axios也提供了类似于jQuery中$.ajax()的函数，语法如下：

```js
axios({
    method: '请求类型',
    url: '请求的URL地址',
    data: { /* POST数据 */ },
    params: { /* GET参数 */ }
}).then(callback)
```

1. 直接使用axios发起GET请求

   ```js
   axios({
       method: 'GET',
       url: 'http://www.liulongbin.top:3006/api/get',
       params: { // GET参数要通过params属性提供
           name: 'zs',
           age: 20
       }
   }).then(function(res) {
       console.log(res.data)
})
   ```
   
2. 直接使用axios发起POST请求

   ```js
   axios({
       method: 'POST',
       url: 'http://www.liulongbin.top:3006/api/post',
       data: { // POST数据要通过data属性提供
       	bookname: '程序员的自我修养',
           price: 666
       }
   }).then(function(res) {
       console.log(res.data)
   })
   ```

# 4. 跨域与JSONP

目标：

- 能够知道什么是同源策略和跨域
- 能够知道什么是JSONP
- 能够说出JSONP的实现原理
- 能够知道防抖和节流的概念

## 4.1 了解同源策略和跨域

### 4.1.1 同源策略

1. 什么是同源

   如果两个页面的**协议**，**域名**和**端口**都相同，则两个页面具有**相同的源**。

   例如，下表给出了相对于http://www.test.com/index.html页面的同源检测：

   协议：http

   域名：www.test.com

   端口：冒号数字是端口，如果没有的话就默认端口号为80

   | URL                                | 是否同源 | 原因                                  |
   | ---------------------------------- | -------- | ------------------------------------- |
   | http://www.test.com/other.html     | 是       | 同源(协议、域名、端口相同)            |
   | https://www.test.com/about.html    | 否       | 协议不同(http与https)                 |
   | http://blog.test.com/movie.html    | 否       | 域名不同(www.test.com与blog.test.com) |
   | http://www.test.com:7001/home.html | 否       | 端口不同(默认的80端口与7001端口)      |
   | http://www.test.com:80/main.html   | 是       | 同源(协议、域名、端口相同)            |

2. 什么是同源策略

   **同源策略**(英文全称Same origin policy)是**浏览器**提供的一个**安全功能**。

   MDN官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

   通俗的理解：浏览器规定，A网站的JavaScript，不允许和**非同源**的网站C之间，进行资源的交互，例如：

   （1）无法读取非同源网页的Cookie、LocalStorage和IndexedDB

   （2）无法接触非同源网页的DOM

   （3）无法向非同源地址发送Ajax请求

### 4.1.2 跨域

1. 什么是跨域

   **同源**指的是两个URL的协议、域名、端口一致，反之，则是**跨域**。

   出现跨域的根本原因：**浏览器的同源策略**不允许非同源的URL之间进行资源的交互。

   网页：http://www.test.com/index.html

   接口：http://www.api.com/userlist

2. 浏览器对跨域请求的拦截

   注意：浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器拦截，无法被页面获取到！

3. 如何实现跨域数据请求

   现如今，实现跨域数据的请求，最主要的两种解决方案，分别是**JSONP**和**CORS**。

   JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种**临时解决方案**。缺点是**只支持GET请求**，不支持POST请求。

   CORS：出现的晚，它是W3C标准，属于跨域Ajax请求的根本解决方案。支持GET和POST请求。缺点是不兼容某些低版本的浏览器。

## 4.2 JSONP

### 4.2.1 什么是JSONP

JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。

### 4.2.2 JSONP的实现原理

由于**浏览器同源策略**的限制，网页中**无法通过Ajax请求非同源的接口数据**。但是<script>标签不受浏览器同源策略的影响，可以通过src属性，请求非同源的js脚本。

因此，JSONP的实现原理，就是通过<script>标签的src属性，请求跨域的数据接口，并通过**函数调用**的形式，接收跨域接口响应回来的数据。

### 4.2.3 自己实现一个简单的JSONP

1. 先定义一个success回调函数

   ```js
   <script>
       function success(data) {
       console.log('拿到了data数据：')
       console.log(data)
   }
   </script>
   ```

2. 通过<script>标签的src属性,请求接口数据：     函数的调用，同时通过查询字符串的形式传递函数名称

   ```js
   <script src="http://ajax/frontend.itheima.net:3006/api/jsonp?callback=success&name=zs&age=20"></script>
   ```

### 4.2.4 JSONP的缺点

由于JSONP是通过<script>标签的src属性，来实现跨域数据获取的，所以，JSONP只支持GET数据请求，不支持POST请求。

注意：**JSONP和Ajax之间没有任何关系**，不能把JSONP请求数据的方式叫做Ajax，因为JSONP没有用到XMLHttpRequest这个对象。

### 4.2.5 jQuery中的JSONP

jQuery提供的$.ajax()函数，除了可以发起真正的Ajax数据请求之外，还能够发起JSONP数据请求，例如：

```js
$.ajax({
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
    // 如果要使用$.ajax()发起JSONP请求，必须指定datatype为jsonp
    dataType: 'jsonp',
    success: function(res) {
        console.log(res)
    }
})
```

默认情况下，使用jQuery发起JSONP请求，会自动携带一个**callback=jQueryxxx**的参数，**jQueryxxx**是随机生成的一个回调函数名称。

### 4.2.6 自定义参数及回调函数名称

在使用jQuery发起JSONP请求时，如果想要自定义JSONP的**参数**以及**回调函数名称**，可以通过如下两个参数来指定：

```js
$.ajax({
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
    dataType: 'jsonp',
    // 发送到服务端的参数名称，默认值为callback
    jsonp: 'callback',
    // 自定义的回调函数，默认值为jQueryxxx格式
    jsonpCallback: 'abc',
    success: function(res) {
        console.log(res)
    }
})
```

### 4.2.7 jQuery中JSONP的实现过程

jQuery中的JSONP，也是通过<script>标签的src属性实现跨域数据访问的，只不过，jQuery采用的是**动态创建和移除<script>标签**的方式，来发起JSONP请求。

- 在**发起JSONP请求**的时候，动态向<header>中append一个<script>标签；
- 在**JSONP请求成功**后，动态从<header>中移除刚才append进去的<script>标签；

## 4.3 案例-淘宝搜索

### 4.3.1 要实现的UI效果

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649317419945.png" alt="1649317419945" style="zoom:50%;" />

### 4.3.2 获取用户输入的搜索关键词

为了获取到用户每次按下键盘输入的内容，需要监听输入框的keyup事件，示例代码如下：

```js
// 监听文本框的keyup事件
$('#ipt').on('keyup',function() {
    // 获取用户输入的内容
    var keywords = $(this).val().trim()
    // 判断用户输入的内容是否为空
    if (keywords.length <= 0) {
        return 
    }
})
```

### 4.3.3 封装getSuggestList函数

将获取搜索建议列表的代码，封装到getSuggestList函数中，示例代码如下：

```js
function getSuggestList(kw) {
    $.ajax({
        // 指定请求的URL地址，其中q是用户输入的关键字
        url: 'https://suggest.taobao.com/sug?q='+kw,
        // 指定要发起的是JSONP请求
        dataType: 'jsonp',
        // 成功的回调函数
        success: function(res) {
            console.log(res)
        }
    })
}
```

### 4.3.4 渲染建议列表的UI结构

1. 定义搜索建议列表

   ```html
   <div class="box">
       <!-- tab栏区域 -->
       <div class="tabs"></div>
       <!-- 搜索区域 -->
       <div class="search-box"></div>
       
       <!-- 搜索建议列表 -->
       <div id="suggest-list"></div>
   </div>
   ```

2. 定义模板结构

   ```html
   <!-- 模板结构 -->
   <script type="text/html" id="tpl-suggestList">
   	{{each result}}
   		<div class="suggest-item">{{$value[0]}}</div>
   	{{/each}}
   </script>
   ```

3. 定义渲染模板结构的函数

   ```js
   // 渲染建议列表
   function renderSuggestList(res) {
       // 如果没有需要渲染的数据，则直接return
       if (res.result.length <=0 ) {
           return $('#suggest-list').empty().hide()
       }
       // 渲染模板结构
       var htmlStr = template('tpl-suggestList',res)
       $('#suggest-list').html(htmlStr).show()
   }
   ```

4. 搜索关键词为空时隐藏搜索建议列表

   ```js
   $('#ipt').on('keyup',function() {
       // 获取用户输入的内容
       var keywords = $(this).val().trim()
       // 判断用户输入的内容是否为空
       if (keywords.length <= 0) {
           // 如果关键词为空，则清空后隐藏搜索建议列表
           return $('#suggest-list').empty().hide()
       }
   })
   ```

### 4.3.5 输入框的防抖

1. 什么是防抖

   **防抖策略**(debounce)是当事件被触发后，**延迟n秒**后再执行回调，如果在这**n秒内事件又被触发**，则**重新计时**。

2. 防抖的应用场景

   用户在输入框中连续输入一串字符串时，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效较少请求次数，节约请求资源；

3. 实现输入框的防抖

   ```js
   var timer = null; // 1. 防抖动的timer
   function debounceSearch(keywords) { // 2. 定义防抖的函数
       timer = setTimeout(function() {
           // 发起JSONP请求
           getSuggestList(keywords)
       },500)
   }
   $('#ipt').on('keyup',function() { // 3. 在触发keyup事件时，立即清空timer
       clearTimeout(timer)
       // 省略其他代码
       debounceSearch(keywords)
   })
   ```

### 4.3.6 缓存搜索的建议列表

1. 定义全局缓存对象

   ```js
   // 缓存对象
   var cacheObj = {}
   ```

2. 将搜索结果保存到缓存对象中

   ```js
   // 渲染建议列表
   function renderSuggestList(res) {
       // ...省略其他代码
       
       // 将搜索的结果，添加到缓存对象中
       var k = $('#ipt').val().trim()
       cacheObj[k] = res
   }
   ```

3. 优先从缓存中获取搜索建议

   ```js
   // 监听文本框的keyup事件
   $('#ipt').on('keyup',function() {
       // ...省略其他代码
       
       // 优先从缓存中获取搜索建议
       if (cacheObj[keywords]) {
           return renderSuggestList(cacheObj[keywords])
       }
       // 获取搜索建议列表
       debounceSearch(keywords)
   })
   ```

   

## 4.4 防抖和节流

### 4.4.1 什么是节流

**节流策略**(trhottle)，顾名思义，可以减少一段时间内事件的触发频率。

### 4.4.2 节流的应用场景

（1）鼠标连续不断地触发某事件(如点击)，只在单位时间内只触发一次；

（2）懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费CPU资源；

### 4.4.3 节流案例--鼠标跟随效果

1. 渲染UI结构并美化样式

   ```html
   <!-- UI结构 -->
   <img src="./assets/angel.gif" id="angel" />
   /* css样式 */
   html, body {
   	margin: 0;
   	padding: 0;
   	overflow: hidden;
   }
   #angel {
   	position: absolute;
   }
   ```

2. 不使用节流时实现鼠标跟随事件

   ```js
   $(function() {
       // 获取图片元素
       var angel = $('#angel')
       // 监听文档的mousemove事件
       $(document).on('mousemove',function(e) {
           // 设置图片的位置
           $(angel).css('left', e.pageX + 'px').css('top', e.pageY + 'px')
       })
   })
   ```

3. 节流阀的概念

   高铁卫生间是否被占用，由红绿灯控制，**红灯**表示**被占用**，**绿灯**表示**可使用**。

   假设每个人上卫生间都需要花费**5分钟**，则**五分钟之内**，被占用的卫生间无法被其他人使用。

   上一个人使用完毕后，需要将红灯**重置**为绿灯，表示下一个人可以使用卫生间。

   下一个人在上卫生间之前，需要**先判断控制灯**是否为绿色，来知晓能否上卫生间。

   **节流阀为空，表示可执行下次操作；不为空，表示不能执行下次操作**。

   当前操作执行完，必须将节流阀**重置**为空，表示可以执行下次操作了。

   每次执行操作前，必须**先判断节流阀是否为空**。

4. 使用节流优化鼠标跟随效果

   ```js
   $(function() {
   	var angel = $('#angel')
       var timer = null  // 1. 预定义一个timer节流阀
       $(document).on('mousemove',function(e) {
           if (timer) {return}  // 3. 判断节流阀是否为空，如果不为空，则证明距离上次执行时间间隔不足16毫秒
           timer = setTimeout(function() {
               $(angel).css('left', e.pageX + 'px').css('top', e.pageY + 'px')
               timer = null // 2. 当设置了鼠标跟随效果后，清空timer节流阀，方便下次开启延时定时器
           },16)
       })
   })
   ```

### 4.4.4 总结防抖和节流的区别

- 防抖：如果事件被频繁触发，防抖能保证**只有最后一次触发生效**！前面N多次的触发都会被忽略！
- 节流：如果事件被频繁触发，节流能够**减少事件触发的频率**，因此，节流是**有选择性地**执行一部分事件！

# 5. HTTP协议加强

目标：

- 能够说出什么是HTTP协议
- 能够知道HTTP请求消息的组成部分
- 能够知道HTTP响应消息的组成部分
- 能够说出常见的请求方法
- 能够说出常见的响应状态码

## 5.1 HTTP协议简介

### 5.1.1 什么是通信

通信，就是**信息的传递和交换**。

通信三要素：

- 通信的**主体**
- 通信的**内容**
- 通信的**方式**

1. 现实生活中的通信

   案例：张三要把自己考上传智专修学院的好消息写信告诉自己的好朋友李四。

   其中：

   通信的主体是张三和李四；

   通信的内容是考上传智专修学院；

   通信的方式是写信；

2. 互联网中的通信

   案例：服务器把传智专修学院的简介通过响应的方式发送给客户端浏览器。

   其中：

   通信的主体是服务器和客户端浏览器；

   通信的内容是传智专修学院的简介；

   通信的方式是响应；

### 5.1.2 什么是通信协议

通信协议(Communication Protocol)是指通信的双方完成通信所必须遵守的规则和约定。

通俗的理解：通信双方采用约定好的格式来发送和接收消息，这种事先约定好的通信格式，就叫做通信协议。

1. 现实生活中的通信协议

   张三与李四采用写信的方式进行通信，在填写信封时，写信的双方需要遵守固定的规则。**信封的填写规则**就是一种通信协议。

2. 互联网中的通信协议

   客户端与服务器之间要实现**网页内容**的传输，则通信的双方必须遵守**网页内容的传输协议**。

   网页内容又叫做**超文本**，因此网页内容的传输协议又叫做**超文本传输协议**(Hyper Text Transfer Protocol)，简称HTTP协议。

### 5.1.3 HTTP

1. 什么是HTTP协议

   HTTP协议即超文本传送协议(Hyper Text Transfer Protocol)，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。

   例如：

   - 客户端要以HTTP协议要求的格式把数据提交到服务器
   - 服务器要以HTTP协议要求的格式把内容响应给客户端

2. HTTP协议的交互模型

   HTTP协议采用了**请求/响应**的交互模型。

   客户端发送一个HTTP请求，服务端就会返回一个HTTP响应，当响应返回以后，本次交互完成

## 5.2 HTTP请求消息

### 5.2.1 什么是HTTP请求消息

由于HTTP协议属于客户端浏览器和服务器之间的通信协议。因此，客户端发起的请求叫做HTTP请求，客户端发送到服务器的消息，叫做HTTP请求消息。

注意：HTTP**请求消息**又叫做**请求报文**。

### 5.2.2 HTTP请求消息的组成部分

HTTP请求消息由**请求行**(request line)、**请求头部**(header)、**空行**和**请求体**4个部分组成。

1. 请求行

   **请求行**由**请求方式**、**URL**和**HTTP协议版本**3个部分组成，他们之间使用空格隔开。

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649736209103.png" alt="1649736209103" style="zoom:80%;" />

2. 请求头部

   **请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。**比如：User-Agenet用来说明当前是什么类型的浏览器；Content-Type用来描述发送到服务器的数据格式；Accept用来描述客户端能够接收什么类型的返回内容；Accept-Language用来描述客户端期望接收哪种人类语言的文本内容。

   请求头部由多行键/值对组成，每行的键和值之间用英文的冒号分隔。

   常见的请求头字段：

   | 头部字段            | 说明                                       |
   | ------------------- | ------------------------------------------ |
   | Host                | 要请求的服务器域名                         |
   | Connection          | 客户端与服务器的连接方式(close或keepalive) |
   | Content-Length      | 用来描述请求体的大小                       |
   | **Accept**          | **客户端可识别的响应内容类型列表**         |
   | **User-Agent**      | **产生请求的浏览器类型**                   |
   | **Content-Type**    | **客户端告诉服务器实际发送的数据类型**     |
   | Accept-Encoding     | 客户端可接收的内容压缩编码形式             |
   | **Accept-Language** | **用户期望获得的自然语言的有限顺序**       |

   

   ![1649736686101](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649736686101.png)

   ![1649736752614](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649736752614.png)

   关于更多请求头字段的描述，可以查看MDN官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers

3. 空行

   最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。

   请求消息中的空行，用来分隔**请求头部**与**请求体**。

4. 请求体

   请求体中存放的，是要通过**POST方式**提交到服务器的数据。

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649745904692.png" alt="1649745904692" style="zoom:50%;" />

   **注意**：只有POST请求才有请求体，GET请求没有请求体。

## 5.3 HTTP响应消息

### 5.3.1 什么是HTTP响应消息

响应消息就是服务器响应给客户端的消息内容，也叫作响应报文。

### 5.3.2 HTTP响应消息的组成部分

HTTP响应消息由**状态行、响应头部、空行和响应体**4个部分组成。

1. 状态行

   状态行由HTTP版本协议、状态码和状态码的描述文本3个部分组成，他们之间使用空格隔开；

   ![1649747906164](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649747906164.png)

2. 响应头部

   **响应头部**用来描述**服务器的基本信息**。响应头部由多行键/值对组成，每行的键和值之间用英文的冒号分隔。

   常见的响应头部字段

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649748130647.png" alt="1649748130647" style="zoom:80%;" />

   ![1649748187785](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649748187785.png)

   关于更多响应头字段的描述，可以查看MDN官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers

3. 空行

   在最后一个响应头字段结束之后，会紧跟一个空行，用来通知客户端响应头部至此结束。

   响应消息中的空行，用来**分隔响应头部与响应体**。

4. 响应体

   响应体中存放的，是服务器响应给客户端的资源内容。

   ![1649748708800](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649748708800.png)

   ![1649748734954](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649748734954.png)

## 5.4 HTTP请求方法

### 5.4.1 什么是HTTP请求方法

HTTP请求方法，属于HTTP协议中的一部分，请求方法的作用是：用来表明**要对服务器上的资源执行的操作**。

最常用的请求方法是GET和POST。

### 5.4.2 HTTP的请求方法

| 序号  | 方法       | 描述                                                         |
| ----- | ---------- | ------------------------------------------------------------ |
| 1     | **GET**    | **(查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议中** |
| **2** | **POST**   | **(新增)向服务器提交资源(例如提交表单或上传文件)。数据被包含在请求体中提交给服务器。** |
| **3** | **PUT**    | **(修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。** |
| **4** | **DELETE** | **(删除)请求服务器删除指定的资源。**                         |
| 5     | HEAD       | HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体。    |
| 6     | OPTIONS    | 获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。 |
| 7     | CONNECT    | 建立一个到由目标资源标识的服务器的隧道。                     |
| 8     | TRACE      | 沿着目标资源的路径执行一个消息环回测试，主要用于测试或诊断。 |
| 9     | PATCH      | 是对PUT方法的补充，用来对已知资源进行局部更新。              |

## 5.5 HTTP响应状态码

### 5.5.1 什么是HTTP响应状态码

**HTTP响应状态码**(HTTP Status Code)，也属于HTTP协议的一部分，**用来标识响应的状态**。

响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次HTTP请求的结果是成功好使失败了。

![1649749822126](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649749822126.png)

### 5.5.2 HTTP响应状态码的组成及分类

HTTP状态码由**三个十进制数字**组成，**第一个十进制数字**定义了**状态码的类型**，后两个数组用来对状态码进行细分。

HTTP状态码共分为5种类型：

| 分类    | 分类描述                                                     |
| ------- | ------------------------------------------------------------ |
| 1**     | 信息，服务器收到请求，需要请求者继续执行操作(实际开发中很少遇到1**类型的状态码) |
| 2**     | **成功，操作被成功接收并处理**                               |
| **3**** | **重定向，需要进一步的操作以完成请求**                       |
| **4**** | **客户端错误，请求包含语法错误或无法完成请求**               |
| **5**** | **服务器错误，服务器在处理请求的过程中发生了错误**           |

1. 2**成功相关的响应状态码

   2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2**类型的状态码如下：

   | 状态码 | 状态码英文名称 | 中文描述                                                |
   | ------ | -------------- | ------------------------------------------------------- |
   | 200    | OK             | 请求成功。一般用于GET与POST请求                         |
   | 201    | Created        | 已创建。成功请求并创建了新的资源，通常用于POST或PUT请求 |

2. 3**重定向相关的响应状态码

   3** 范围的状态码，表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3**类型的状态码如下：

   | 状态码 | 状态码英文描述    | 中文描述                                                     |
   | ------ | ----------------- | ------------------------------------------------------------ |
   | 301    | Moved Permanently | 永久移动。请求的资源已被永久戴尔移动到新的URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
   | 302    | Found             | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
   | 304    | Not Modified      | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源(响应消息中不包含响应体)。客户端通常会缓存访问过的资源 |

3. 4**客户端错误相关的响应状态码

   4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求的失败。常见的 4** 类型的状态码如下：

   | 状态码  | 状态码英文名称  | 中文描述                                                     |
   | ------- | --------------- | ------------------------------------------------------------ |
   | 400     | Bad Request     | 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。 |
   | 401     | Unauthorized    | 当前请求需要用户验证。                                       |
   | 403     | Forbidden       | 服务器已经理解请求，但是拒绝执行它。                         |
   | **404** | **Not Found**   | **服务器无法根据客户端的请求找到资源(网页)。**               |
   | 408     | Request Timeout | 请求超时。服务器等待客户端发送的请求时间过长，超时。         |

4. 5** 服务端错误相关的响应状态码

   5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。常见的5** 类型的状态码如下：

   | 状态码 | 状态码英文名称        | 中文描述                                                     |
   | ------ | --------------------- | ------------------------------------------------------------ |
   | 500    | Internal Server Error | 服务器内部错误，无法完成请求。                               |
   | 501    | Not Implemented       | 服务器不支持该请求方法，无法完成请求。只有GET和HEAD请求方式是要求每个服务器必须支持的，其他请求方法在不支持的服务器上会返回501 |
   | 503    | Service Unavaliable   | 由于超载或系统维护，服务器暂时的无法处理客户端的请求         |



# 6. Git

目标

- 能够掌握Git基本命令的使用
- 能够使用Github创建和维护远程仓库
- 能够掌握Git分支的基本使用

## 6.1 起步

### 6.1.1 起步-关于版本控制

1. 文件的版本

   缺点：

   （1）操作麻烦：每次都要复制粘贴重命名

   （2）命名不规范：无法知道文件名具体做了哪些修改

   （3）容易丢失：如果硬盘故障或不小心删除，文件很容易丢失

   （4）协作困难：需要手动合并每个人对项目文件的修改，合并时极易出错

2. 版本控制软件

   概念：版本控制软件是一个用来记录文件变化，以便将来查阅特定版本修订情况的系统，因此有时也叫做“版本控制系统”。

   通俗的理解：把手工管理文件版本的方式，改为由软件管理文本的版本；这个负责管理文件版本的软件，叫做“版本控制软件”。

3. 使用版本控制软件的好处

   （1）操作简便：只需识记几组简单的终端命令，即可快速上手常见的版本控制软件

   （2）易于对比：基于版本控制软件提供的功能，能够方便地比较文件的变化细节，从而查找出导致问题的原因。

   （3）可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态

   （4）不易丢失：在版本控制软件中，被用户误删的文件，可以轻松的恢复回来

   （5）协作方便：基于版本控制软件提供的分支功能，可以轻松实现多人协作开发时的代码合并操作

4. 版本控制系统的分类

   **本地版本控制系统**：单机运行，使维护文件版本的操作工具化

   特点：使用软件来记录文件的不同版本，提高了工作效率，降低了手动维护版本的出错率

   缺点：（1）单机运行，不支持多人协作开发

   ​		    （2）版本数据库故障后，所有历史更新记录会丢失

   **集中化的版本控制系统(典型代表：SVN)**：联网运行，支持多人协作开发；性能差、用户体验不好

   特点：基于服务器、客户端的运行模式

   （1）服务器保存文件的所有更新记录

   （2）客户端只保留最新的文件版本

   优点：联网运行，支持多人协作开发

   缺点：（1）不支持离线提交版本更新

   ​			（2）中心服务器崩溃后，所有人无法正常工作

   ​			（3）版本数据库故障后，所有历史更新记录会丢失

   **分布式版本控制系统(典型代表：Git)**：联网运行，支持多人协作开发；性能优秀、用户体验好

   特点：基于服务器、客户端的运行模式

   - 服务器保存文件的所有更新版本
   - 客户端是服务器的完整备份，并不是只保留文件的最新版本

   优点：（1）联网运行，支持多人协作开发

   ​			（2）客户端断网后支持离线本地提交版本更新

   ​			（3）服务器故障或损坏后，可使用任何一个客户端的备份进行恢复

### 6.1.2 起步-Git基础概念

1. 什么是Git

   Git是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理。

   特点：项目越大越复杂，协同开发者越多，越能体现出Git的高性能和高可用性！

2. Git的特性

   Git之所以快速和高效，主要依赖于它的如下两个特性：

   （1）直接记录快照，而非差异比较

   （2）近乎所有操作都是本地执行

   2.1 SVN的差异比较

   传统的版本控制系统(例如SVN)是基于差异的版本控制，它们存储的是一组基本文件和每个文件随事件逐步积累的差异。

   好处：节省磁盘空间

   缺点：耗时、效率低

   在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件。

   2.2 Git的记录快照

   Git快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git不在重新存储该文件，而是只保留一个链接指向之前存储的文件。

   缺点：占用磁盘空间较大

   优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。

   特点：空间换时间

   2.3 近乎所有的操作都是本地执行

   在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。

   特性：

   （1）断网后依旧可以在本地对项目进行版本管理

   （2）联网后，把本地修改的记录同步到云端服务器即可

3. Git中的三个区域

   **使用Git管理的项目，拥有三个区域**，分别是**工作区、暂存区、Git仓库**。

   工作区：处理工作的区域

   暂存区：已完成的工作的临时存放区域，等待被提交

   Git仓库：最终的存放区域

4. Git中的三种状态

   - 已修改modified：表示修改了文件，但还没将修改的结果放到暂存区
   - 已暂存staged：表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中
   - 已提交committed：表示文件已经安全地保存在本地的Git仓库中

   注意：

   - 工作区的文件被修改了，但还没有放到暂存区，就是已修改状态
   - 如果文件已修改并放入暂存区，就属于已暂存状态
   - 如果Git仓库中保存着特定版本的文件，就属于已提交状态

5. 基本的Git工作流程

   （1）在工作区中修改文件

   （2）将你想要下次提交的更改进行暂存

   （3）提交更新，找到暂存区的文件，将快照永久性存储到Git仓库

## 6.2 Git基础

### 6.2.1 安装并配置Git

在开始使用Git管理项目的版本之前，需要将它安装到计算机上。可以使用浏览器访问如下的网址，根据自己的操作系统，选择下载对应的Git安装包：

https://git-scm.com/downloads

### 6.2.2 配置用户信息

1. 安装完Git之后，要做的第一件事就是**设置自己的用户名和邮件地址**。因为通过Git对项目进行版本管理的时候，Git需要使用这些基本信息，来记录是谁对项目进行了操作：

- git config --global user.name “itheima”
- git config --global user.email “itheima@itcast.cn”

注意：如果使用了 --global选项，那么该命令只需要运行一次，即可永久生效。

2. Git的全局配置文件

通过git config --global user.name和git config --global user.email配置的用户名和邮箱地址，会被写入到**C:/User/用户名文件夹/.gitconfig**文件中。这个文件是Git的**全局配置文件**，**配置一次即可永久生效**。

可以使用记事本打开此文件，从而**查看自己曾经对Git做了哪些全局性的配置**。

windows+E→C盘→用户→Administrator→.gitconfig记事本打开

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649817953885.png" alt="1649817953885" style="zoom:50%;" />

3. 检查配置信息

除了使用记事本查看全局的配置信息之外，还可以运行如下的终端命令，快速的查看Git的全局配置信息：

#查看所有的全局配置项

**git config --list --global**

#查看指定的全局配置项

**git config user.name**

**git config user.email**

4. 获取帮助信息

可以使用git help <verb>命令，无需联网即可在浏览器中打开帮助手册，例如：

#要想打开 git config 命令的帮助手册

git help config

如果不想查看完整的手册，那么可以用 -h选项获得更简明的“help”输出：

#想要获取git config命令的快速参考

git config -h

### 6.2.3 Git的基本操作

#### 6.2.3.1 获取Git仓库的两种方式

（1）将尚未进行版本控制的**本地目录转换为Git仓库**

（2）从其他服务器**克隆**一个已存在的Git仓库

以上两种方式都能够在自己的电脑上得到一个可用的Git仓库

#### 6.2.3.2 在现有目录中初始化仓库

如果自己有一个尚未进行版本控制的项目目录，想要用Git来控制它，需要执行如下两个步骤：

（1）在项目目录中，通过鼠标右键打开“Git Bash”

（2）执行 **git init** 命令将当前的目录转化为Git仓库

![1649906265688](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649906265688.png)

git init 命令会创建一个名为.git的隐藏目录，**这个.git目录就是当前项目的Git仓库**，里面包含了**初始的必要文件**，**这些文件是Git仓库的必要组成部分**。

![1649906288541](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649906288541.png)

#### 6.2.3.3 工作区中文件的4种状态

工作区中的每一个文件可能有4种状态，这四种状态共分为两大类，如图所示：

![1649820647008](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649820647008.png)

Git操作的终极结果:让工作区中的文件都处于**“未修改”**的状态。

#### 6.2.3.4 检查文件的状态

可以使用git status命令查看文件处于什么状态，例如：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649821069991.png" alt="1649821069991" style="zoom:80%;" />

在状态报告中可以看到新建的index.html文件出现在**Untracked files**(未跟踪的文件)下面。

未跟踪的文件意味着**Git在之前的快照(提交)中没有这些文件**；Git不会自动将之纳入跟踪范围，除非明确地告诉它”我需要使用Git跟踪管理该文件“。

#### 6.2.3.5 以精简的方式显示文件状态

使用**git status**输出的状态报告很详细，但有些繁琐。如果希望**以精简的方式显示文件的状态**，可以使用如下两条完全等价的命令，其中 **-s 是 --short**的简写形式：

#以精简的方式显示文件的状态

git status -s

git status --short

未跟踪文件前面有红色的？？标记，例如：

![1649848393339](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649848393339.png)

#### 6.2.3.6 跟踪新文件

使用 **git add** 命令开始跟踪一个文件。所以，要跟踪index.html文件，运行如下的命令即可：

git add index.html

此时再运行**git status** 命令，会看到index.html文件在**Changes to be commited**这行的下面，说明**已被跟踪**，**并处于暂存状态**：

![1649849003254](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649849003254.png)

以精简的方式显示文件的状态：新添加到暂存区中的文件前面有绿色的A标记

![1649849073292](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649849073292.png)

#### 6.2.3.7 提交更新

现在暂存区中有一个index.html文件**等待被提交**到Git仓库中进行保存，可以执行**git commit**命令进行提交，其中

**-m选项**后面是本次的提交消息，用来**对提交的内容做进一步的描述**：

![1649906539506](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649906539506.png)

提交成功之后，再次检查文件的状态，得到提示如下：

![1649906617640](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649906617640.png)

证明工作区中所有的文件都处于“未修改”状态，没有任何文件需要被提交。

![1649906764205](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649906764205.png)

#### 6.2.3.8 对已提交的文件进行修改

目前，index.html文件已经被Git跟踪，并且工作区和Git仓库中的index.html文件内容保持一致。当我们修改了工作区中的index.html的内容之后，再次运行git status和git status -s命令，会看到如下的内容：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649907155571.png" alt="1649907155571" style="zoom:80%;" />

文件index.html出现在Changes not staged for commit这行下面，说明**已跟踪文件的内容发生了变化**，**但还没有放到暂存区**。

注意：修改过的、没有放入暂存区的文件前面有红色的M标记。

#### 6.2.3.9 暂存已修改的文件

目前，工作区中的index.html文件已被修改，如果要暂存这次修改，需要再次运行**git add**命令，这个命令是个多功能的命令，主要有如下3个功效：

（1）可以用它**开始跟踪新文件**

（2）把**已跟踪的、且已修改的**文件放到暂存区

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649907740130.png" alt="1649907740130" style="zoom:50%;" />

（3）把有冲突的文件标记为已解决状态

#### 6.2.3.10 提交已暂存的文件

再次运行**git commit -m ”提交消息“** 命令，即可将暂存区中记录的index.html的快照，提交到Git仓库中进行保存：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649908035591.png" alt="1649908035591" style="zoom:50%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649908086568.png" alt="1649908086568" style="zoom: 80%;" />

#### 6.2.3.11 撤销对文件的修改

撤销对文件的修改指的是：把对工作区中对应文件的修改，**还原**成Git仓库中所保存的版本。

操作的结果：所有的修改会丢失，且无法恢复！**危险性较高，请慎重操作**！

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649908303862.png" alt="1649908303862" style="zoom:80%;" />

撤销操作的实质：用Git仓库中保存的文件，覆盖工作区中指定的文件。

#### 6.2.3.12 向暂存区中一次性添加多个文件

如果需要被暂存的文件个数比较多，可以使用如下的命令，一次性将所有的新增和修改过的文件加入暂存区：

git add .

注意：**今后在项目开发中，会经常使用这个命令，将新增和修改过后的文件加入暂存区**。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649909150457.png" alt="1649909150457" style="zoom: 50%;" />

#### 6.2.3.13 取消暂存的文件

如果需要从暂存区中移除对应的文件，可以使用如下的命令：

**git reset HEAD 要移除的文件名称**

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649909581510.png" alt="1649909581510" style="zoom:50%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649909719043.png" alt="1649909719043" style="zoom:50%;" />

所有文件都被加入暂存区，此时工作区中没有需要修改以及需要暂存的文件：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649909930898.png" alt="1649909930898" style="zoom: 50%;" />

#### 6.2.3.14 跳过使用暂存区

Git标准的工作流程是**工作区→暂存区→Git仓库**，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将工作区中的修改提交到Git仓库，这时候Git工作的流程简化为了**工作区→Git仓库**。

Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给**git commit**加上**-a**选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add 步骤：

git commit -a -m “描述消息”

#### 6.2.3.15 移除文件

从Git仓库中移除文件的方式有两种：

（1）从Git仓库和工作区中**同时移除**对应的文件

**git rm -f index.js**

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649921298186.png" alt="1649921298186" style="zoom:50%;" />

（2）只从Git仓库中移除指定的文件，但保留工作区中对应的文件

**git rm --cached index.css**

![1649921698190](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649921698190.png)

![1649921718981](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649921718981.png)

#### 6.2.3.16 忽略文件

一般我们总会有些文件无需纳入Git的管理，也不希望它们总能在未跟踪文件列表。在这种情况下，我们可以创建一个名为**.gitignore**的配置文件，列出要忽略的文件的匹配模式。

文件.gitignore的格式规范如下：

（1）以**#开头**的是注释

（2）以**/结尾**的是目录

（3）以**/开头**防止递归

（4）以**！**开头表示取反

（5）可以使用glob模式进行文件和文件夹的匹配(glob指简化了的正则表达式)

#### 6.2.3.17 glob模式

所谓的glob模式是指简化了的正则表达式：

（1）**星号***匹配**零个或多个任意字符**

（2）**[abc]**匹配**任何一个列在方括号中的字符**(此案例匹配一个a或匹配一个b或匹配一个c)

（3）**问号？**只**匹配一个任意字符**

（4）在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配(比如[0-9]表示匹配所有0-9的数字)

（5）**两个星号 **** 表示**匹配任意中间目录**(比如a/ * */z可以匹配a/z、a/b/z、a/b/c/z等)

#### 6.2.3.18 .gitignore文件的例子

```js
# 忽略所有的.a文件
*.a

# 但跟踪所有的 lib.a，即便你在前面忽略了.a文件
!lib.a

# 只忽略当前目录下的T000文件，而不忽略subdir/T000
/T000

# 忽略任何目录下名为build的文件夹
build/
    
# 忽略doc/notes.txt，但不忽略doc/server/arch.txt
doc/*.txt

# 忽略doc/ 目录及其所有目录下的.pdf文件
doc/**/*.pdf
```

#### 6.2.3.19 查看提交历史

如果希望回顾项目的提交历史，可以使用**git log**这个简单且有效的命令。

```js
# 按时间先后顺序列出所有的提交历史，最近的提交排在最上面
git log

# 只展示最新的两条提交历史，数字可以按需进行填写
git log -2

# 在一行上展示最近两条提交历史的信息
git log -2 --pretty=oneline

# 在一行上展示最近两条提交历史的信息，并自定义输出的格式
# %h 提交的简写哈希值 %an作者名字 %ar作者修订日期，按多久以前的方式显示 %s提交说明
git log -2 --pretty=form:"%h | %an | %ar | %s"
```

![1649924450763](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649924450763.png)

#### 6.2.3.20 回退到指定的版本

```js
# 在一行上展示所有的提交历史
git log --pretty=oneline

# 使用git reset --hard 命令，根据指定的提交ID回退到指定版本
git reset --hard <CommitID>
    
# 在旧版本中使用git reflog --pretty=oneline命令，查看命令操作的历史
git reflog --pretty=oneline

# 再次根据最新的提交ID，跳转到最新的版本
git reset --hard <CommitID>
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649924937518.png" alt="1649924937518" style="zoom:50%;" />

#### 6.2.3.21 小结

（1）初始化Git仓库的命令

**git init**

（2）查看文件状态的命令

**git status**

**git status -s**

**git status --short**

（3）一次性将文件加入暂存区的命令

**git add .**

（4）将暂存区的文件提交到Git仓库的命令

**git commit -m “提交说明”**



## 6.3 Github

### 6.3.1 了解开源相关的概念

#### 6.3.1.1 什么是开源

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649925671032.png" alt="1649925671032" style="zoom: 67%;" />

通俗的理解：开源是指不仅提供程序还提供程序的源代码

​						闭源是只提供程序，不提供源代码

#### 6.3.1.2 什么是开源许可协议

开源并不意味着完全没有限制，为了**限制使用者的使用范围**和**保护作者的权利**，每个开源项目都应该遵守**开源许可协议**(Open Source License)。

#### 6.3.1.3 常见的5种开源许可协议

（1）BSD(Berkeley Software Distribution)

（2）Apache Licence 2.0

（3）**GPL**(GNU General Public License)

- 具有传染性的一种开源协议，不允许修改后和衍生的代码作为闭源的商业软件发布和销售
- 使用GPL的最著名的软件项目是：Linux

（4）LGPL(GNU Lesser General Public License)

（5）**MIT**(Massachusetts Institute of Technology，MIT)

- 是目前限制最少的协议，唯一的条件：在修改后的代码或者发行包中，必须包含原作者的许可信息
- 使用MIT的软件项目有：jquery、Node.js

关于更多开源许可协议的介绍，可以参考博客https://www.runoob.com/w3cnote/open-source-license.html

#### 6.3.1.4 为什么要拥抱开源

开源的核心思想是“我为人人，人人为我”，人们越来越喜欢开源大致是出于以下3个原因：

（1）开源给使用者更多的控制权

（2）开源让学习变得容易

（3）开源才有真正的安全

开源是软件开发领域的大趋势，**拥抱开源就像站在了巨人的肩膀上**，不用自己重复造轮子，让开发越来越容易。

#### 6.3.1.5 开源项目托管平台

专门用于免费存放开源项目源代码的网站，叫做开源项目托管平台。目前世界上比较出名的开源项目托管平台主要有以下3个：

- Github(全球最牛的开源项目托管平台，没有之一)
- Gitlab(对代码私有性支持较好，因此企业用户较多)
- Gitee(又叫做**码云**，是国产的开源项目托管平台。访问速度快、纯中文界面、使用友好)

注意：以上3个开源项目托管平台，只能托管以Git管理的项目源代码，因此，它们的名字都以Git开头。

#### 6.3.1.6 什么是Github

Github是全球最大的**开源项目托管平台**。因为只支持Git作为唯一的版本控制工具，故名Github。

在Github中，你可以：

（1）关注自己喜欢的开源项目，为其点赞打call

（2）为自己喜欢的开源项目做贡献(Pull Request)

（3）和开源项目的作者讨论Bug和提需求(Issues)

（4）把喜欢的项目复制一份作为自己的项目进行修改(Fork)

（5）创建属于自己的开源项目

（6）etc...

So, **Github ≠ Git**

### 6.3.2 注册账号

#### 6.3.2.1 注册Github账号的流程

（1）访问Github的官网首页https://github.com/

（2）点击“Sign up”按钮跳转到注册页面

（3）填写可用的用户名、邮箱、密码

（4）通过点击箭头的形式，将验证图片摆正

（5）点击“Create account” 按钮注册新用户

（6）登录到第三步填写的邮箱中，点击激活链接，完成注册

### 6.3.3 远程仓库的使用

#### 6.3.3.1 新建空白远程仓库

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649929163325.png" alt="1649929163325" style="zoom:80%;" />

#### 6.3.3.2 新建空白远程仓库成功

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649929550597.png" alt="1649929550597" style="zoom:80%;" />

#### 6.3.3.3 远程仓库的两种访问方式

Github上的远程仓库，有两种访问方式，分别是**HTTPS和SSH**。它们的区别是：

（1）HTTPS：**零配置**；但是每次访问仓库时，需要重复输入Github的账号和密码才能访问成功

（2）SSH：**需要进行额外的配置**；但是配置成功后，每次访问仓库时，不需要重复输入Github的账号和密码

注意：在实际开发中，**推荐使用SSH的方式访问远程仓库**。

#### 6.3.3.4 基于HTTPS将本地仓库上传到Github

![1649931441617](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649931441617.png)

#### 6.3.3.5 SSH Key

SSH key的作用：实现本地仓库和Github之间**免登录**的**加密数据传输**。

SSH Key的好处：免登录身份认证、数据加密传输。

SSH Key由两部分组成，分别是：

id_sra（私钥文件，存放于客户端的电脑中即可）

id_sra.pub（公钥文件，需要配置到Github中）

#### 6.3.3.6 生成SSH Key

（1）打开Git Bash

（2）粘贴如下的命令，并将your_email@example.com替换为注册Github账号时填写的邮箱：

- ssh-keygen -t rsa -b -C “yuor email@example.com”

（3）连续敲击3次回车，即可在**C:\Users \用户名文件夹 \ .ssh**目录中生成id_rsa和id_rsa.pub两个文件

#### 6.3.3.7 配置SSH Key

（1）使用记事本打开**id_rsa.pub**文件，复制里面的文本内容

（2）在浏览器中登录Github，**点击头像→Settings→SSH and GPG Keys→New SSH Key**

（3）将id_rsa.pub文件中的内容，**粘贴到Key对应的文本框中**

（4）在Title文本框中任意填写一个名称，来标识这个Key从何而来

#### 6.3.3.8 检测Github的SSH Key是否配置成功

打开Git Bash，输入如下的命令并回车执行：

ssh -T git@github.com

上述的命令执行成功后，可能会看到如下的提示消息：

![1649993459369](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649993459369.png)

输入yes之后，如果能看到类似于下面的提示消息，证明SSH Key已经配置成功了：

![1649993403828](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649993403828.png)

#### 6.3.3.9 基于SSH将本地仓库上传到Github

（1）准备好本地仓库

- 新建项目文件project_02

- 在根目录下创建三个文件login.html、login.css以及login.js

- 在根目录下鼠标右键点击Git Bash，输入以下命令：

  git init

  git status -s

  git add .

  git status -s

  git commit -m “初始化项目”

  ![1649994494139](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649994494139.png)

  ![1649994538685](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649994538685.png)

（2）准备远程仓库

- 在Github中新建空白远程仓库

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649994697403.png" alt="1649994697403" style="zoom: 50%;" />

- 设置仓库名称，仓库描述等并创建仓库

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649994864147.png" alt="1649994864147" style="zoom:50%;" />

（3）将本地现成的仓库project_02推送到Github

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649995488692.png" alt="1649995488692" style="zoom:50%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649995218583.png" alt="1649995218583" style="zoom:50%;" />

（4）刷新远程仓库，即可得到本地仓库中新建的三个文件

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1649995643714.png" alt="1649995643714" style="zoom:50%;" />



#### 6.3.3.10 将远程仓库克隆到本地

打开Git Bash，输入如下的命令并回车执行：

git clone 远程仓库的地址

当项目文件project_02被误删后，可以将远程仓库中的文件克隆到本地

![1650003380105](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650003380105.png)



## 6.4 Git分支

### 6.4.1 本地分支操作

#### 6.4.1.1 分支的概念

分支就是科幻电影里面的**平行宇宙**，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。

如果两个平行宇宙互补干扰，那对现在的你也没啥影响。

不过，**在某个时间点，两个平行宇宙合并了**，结果，你**既学会了Git又学会了SVN**！

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650003809247.png" alt="1650003809247" style="zoom:80%;" />

#### 6.4.1.2 分支在实际开发中的作用

在进行多人协作开发的时候，为了防止互相干扰，提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发，例如：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650004069555.png" alt="1650004069555" style="zoom: 67%;" />

#### 6.4.1.3 master主分支

在初始化本地Git仓库的时候，Git默认已经帮我们创建了一个名字叫做**master**的分支。通常我们把这个master分支叫做**主分支**。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650004317263.png" alt="1650004317263" style="zoom:67%;" />

在实际工作中，master主分支的作用是：**用来保存和记录整个项目已经完成的功能代码**。

因此，不允许程序员直接在master分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃。

#### 6.4.1.4 功能分支

由于程序员不能直接在master分支上进行功能的开发，所以就有了**功能分支**的概念。

**功能分支**指的是**专门用来开发新功能的分支**，它是临时从master主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到master主分支上，如图所示：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650005902699.png" alt="1650005902699" style="zoom:67%;" />

#### 6.4.1.5 查看分支列表

使用如下的命令，可以查看当前Git仓库中所有的分支列表：

**git branch**

运行的结果如下所示：

![1650009019411](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650009019411.png)

注意：分支名字前面的*****号表示**当前所处的分支**。

#### 6.4.1.6 创建新分支

使用如下的命令，可以**基于当前分支，创建一个新的分支**，此时，新分支中的代码和当前分支完全一样：

**git branch 分支名称**

图示如下：

![1650009288179](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650009288179.png)

![1650009513096](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650009513096.png)

#### 6.4.1.7 切换分支

使用如下的命令，可以**切换到指定的分支上**进行开发：

**git checkout 要切换的分支名字**

**如：git checkout login**

图示如下：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650268986116.png" alt="1650268986116" style="zoom:80%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650269222074.png" alt="1650269222074" style="zoom:80%;" />

#### 6.4.1.8 分支的快速创建和切换

使用如下的命令，可以**创建指定名称的新分支**，并**立即切换到新分支**上：

```js
# -b 表示创建一个新分支
# checkout 表示切换到刚才新建的分支上
git checkout -b 分支名称
```

图示如下：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650269550677.png" alt="1650269550677" style="zoom:67%;" />

注意：“git checkout -b 分支名称”是下面两条命令的简写形式：

（1）git branch 分支名称

（2）git checkout 分支名称

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650269909368.png" alt="1650269909368" style="zoom:50%;" />

#### 6.4.1.9 合并分支

功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到main主分支上：

```js
# 1. 切换到main分支
git checkout main
# 2. 在main分支上运行git merge 命令，将login分支的代码合并到main分支
git merge login
```

图示如下：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650270171087.png" alt="1650270171087" style="zoom: 80%;" />

**合并分支时的注意点：**

假设要把C分支的代码合并到A分支，则必须先切换到A分支上，再运行git merge C命令，来合并C分支！

（1）切换到login分支进行代码开发测试

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650270708854.png" alt="1650270708854" style="zoom: 50%;" />

（2）切换到目标分支main

切换到main主分支之前：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650270833156.png" alt="1650270833156" style="zoom:50%;" />

切换到main主分支之后：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650270891684.png" alt="1650270891684" style="zoom:50%;" />

因为在主分支上没有写任何代码，所以回到main主分支上后，看不到login分支的操作。

（3）执行git merge login

![1650271030174](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650271030174.png)

![1650271054199](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650271054199.png)

#### 6.4.1.10 删除分支

当把功能分支的代码合并到main主分支以后，就可以使用如下的命令，删除对应的功能分支：

```js
git branch -d 分支名称
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650271248951.png" alt="1650271248951" style="zoom:67%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650271391656.png" alt="1650271391656" style="zoom: 50%;" />

注意：删除分支时，不能在即将删除的分支中进行删除操作

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650295145015.png" alt="1650295145015" style="zoom: 67%;" />

#### 6.4.1.11 遇到冲突时的分支合并

如果**在两个不同的分支中**，对**同一个文件**进行了**不同的修改**，Git就没法干净的合并它们。此时，我们需要打开这些包含冲突的文件然后**手动解决冲突**。

```js
# 假设：在把reg分支合并到main分支期间，代码发生了冲突
git checkout main
git merge reg

# 打开包含冲突的文件，手动解决冲突之后，再执行如下的命令
git add .
git commit -m "解决了分支合并冲突的问题"
```

（1）先对reg分支中的login.html进行修改，再对main分支中的login.html进行修改

（2）将reg分支合并到main分支中将产生冲突

![1650279318900](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650279318900.png)

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650280462355.png" alt="1650280462355" style="zoom:67%;" />

### 6.4.2 远程分支操作

#### 6.4.2.1 将本地分支推送到远程仓库

如果是**第一次**将本地分支推送到远程仓库，需要运行如下的命令：

```js
# -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候不要带 -u 参数
git push -u 远程仓库的别名 本地分支名称：远程分支名称

# 实际案例：
git push -u origin payment:pay

# 如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化：
git push -u origin payment
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650293490747.png" alt="1650293490747" style="zoom:67%;" />

注意：第一次推送分支需要带**-u**参数，此后可以直接使用**git push**推送代码到远程分支。

#### 6.4.2.2 查看远程仓库中所有的分支列表

通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：

```js
git remote show 远程仓库名称
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650294244761.png" alt="1650294244761" style="zoom:67%;" />

#### 6.4.2.3 跟踪分支

跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：

```js
# 从远程仓库中，把对应的远程分支下载到本地仓库，保持本地分支和远程分支名称相同
git checkout 远程分支的名称
# 示例：
git checkout pay

# 从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名
git checkout -b 本地分支名称 远程仓库名称/远程分支名称
# 示例：
git checkout -b payment origin/pay
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650294958925.png" alt="1650294958925" style="zoom: 50%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650295382774.png" alt="1650295382774" style="zoom: 50%;" />

#### 6.4.2.4 拉取远程分支的最新的代码

可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：

```js
# 从远程仓库，拉取当前分支最新的代码，保持当前分支的代码和远程分支代码一致
git pull
```

下载之前：

![1650295823226](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650295823226.png)

下载之后：

![1650295930472](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650295930472.png)

#### 6.4.2.5 删除远程分支

可以使用如下的命令，删除远程仓库中指定的分支：

```js
# 删除远程仓库中，指定名称的远程分支
git push 远程仓库的名称 --delete 远程分支名称
# 示例：
git push origin --delete pay
```

![1650296241246](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650296241246.png)

在本地仓库删除reg分支，**如果reg分支没有合并到main分支中**，当执行git branch -d reg代码式会报错：

![1650296503658](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650296503658.png)

如果想要强制删除reg分支，需执行git branch -D reg

![1650296601989](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650296601989.png)

### 6.4.3 总结

（1）能够掌握Git中基本命令的使用

- git init
- git add.
- git commit -m “提交信息”
- git status 和 git status -s

（2）能够使用Github创建和维护远程仓库

- 能够配置Github的SSH访问
- 能够将本地仓库上传到Github

（3）能够掌握Git分支的基本使用

- git checkout -b 新分支名称
- git push -u origin 新分支名称
- git checkout 分支名称
- git branch

# 7. 初识Node.js与内置模块

目标：

- 能够知道什么是Node.js
- 能够知道Node.js可以做什么
- 能够说出Node.js中的JavaScript的组成部分
- 能够使用fs模块读写操作文件
- 能够使用path模块处理路径
- 能够使用http模块写一个基本的web服务器

## 7.1 初识Node.js

### 7.1.1 回顾与思考

1. 已经掌握了哪些技术

   HTML、CSS、JavaScript

2. 浏览器中的JavaScript的组成部分

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650709004911.png" alt="1650709004911" style="zoom:50%;" />

3. 思考：为什么JavaScript可以在浏览器中被执行

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650709191352.png" alt="1650709191352" style="zoom:67%;" />

4. 思考：为什么JavaScript可以操作DOM和BOM

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650709431191.png" alt="1650709431191" style="zoom:67%;" />

5. 浏览器中的JavaScript运行环境

   **运行环境**是指**代码正常运行所需的必要环境**。

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650722301564.png" alt="1650722301564" style="zoom:67%;" />

6. 思考：JavaScript能否做后端开发

   借助于Node.js，把JS代码运行在Node.js中，即可实现后端开发。

### 7.1.2 Node.js简介

1. 什么是Node.js

   Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.

   **Node.js 是**一个基于Chrome V8 引擎的 **JavaScript运行环境**。

   Node.js的官网地址：https://nodejs.org/zh-cn/

2. Node.js中的JavaScript运行环境

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650723461587.png" alt="1650723461587" style="zoom:67%;" />

   注意：

   （1）浏览器是JavaScript的前端运行环境。

   （2）Node.js是JavaScript的后端运行环境。

   （3）Node.js中无法调用DOM和BOM等浏览器内置API。(Node.js是一个独立的运行环境，在Node运行环境中只提供了和Node相关的API，并没有提供浏览器内置的DOM、BOM等API)

3. Node.js可以做什么

   Node.js作为一个JavaScript的运行环境，仅仅提供了基础的功能和API。然而，基于Node.js提供的这些基础功能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了Node.js。可以让前端程序员胜任更多的工作和岗位：

   （1）基于Express框架(http://www.expressjs.com.cn/)，可以快速构建Web应用

   （2）基于Electron框架(https://electronjs.org/)，可以构建跨平台的桌面应用

   （3）基于restify框架(http://restify.com/)，可以快速构建API接口项目

   （4）读写和操作数据库、创建实用的命令行工具辅助前端开发、etc...

   总之：Node.js是大前端时代的“大宝剑”，有了Node.js这个超级buff的加持，前端程序员的行业竞争力会越来越强！

4. Node.js好学吗

   会JavaScript，就能学会Node.js

5. Node.js怎么学

   ![1650724379374](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650724379374.png)

   Node.js学习路径：

   JavaScript基础语法+**Node.js内置API模块**(fs、path、http等)+**第三方API模块**(express、mysql等)

### 7.1.3 Node.js环境的安装

如果希望通过Node.js来运行JavaScript代码，则必须在计算机上安装Node.js环境才行。

1. 区分LTS版本和Current版本的不同

   ![1650724861252](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650724861252.png)

2. 查看已安装的Node.js的版本号

   打开终端，在终端中输入命令**node -v**后，按下回车键，即可查看已安装的Node.js的版本号。

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650725375806.png" alt="1650725375806" style="zoom:67%;" />

   ![1650725394190](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650725394190.png)

3. 什么是终端

   终端(英文：Terminal)是专门为开发人员设计的，**用于实现人机交互**的一种方式。

   作为一名合格的程序员，我们有必要识记一些**常用的终端命令**，来辅助我们更好的操作与使用计算机。

### 7.1.4 在Node.js环境中执行JavaScript代码

（1）打开终端

（2）切换到执行文件所处的目录中：cd C:\Users\Administrator\Desktop\Node.js基础\day1\code

（3）输入 node 要执行的js文件名称

![1650726511419](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650726511419.png)

简便方法：

（1）定位到1.js所处的目录中

（2）在目录的空白区域按下“shift”键，同时单击鼠标右键

（3）点击“在此处打开 Power shell 窗口(s)”

（4）即可直接定位到执行文件所处的目录中

（5）输入node 1.js

1. 终端中的快捷键

   在Windows的Powershell或cmd终端中，我们可以通过如下快捷键，来提高终端的操作效率：

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650727224651.png" alt="1650727224651" style="zoom:80%;" />

## 7.2 fs文件系统模块

### 7.2.1 什么是fs文件系统模块

**fs模块**是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。

例如：

- fs.readFile()方法，用来**读取**指定文件中的内容
- fs.writeFile()方法，用来向指定的文件中**写入**内容

如果要在JavaScript代码中，使用fs模块来操作文件，则需要使用如下的方式先导入它：

```js
const fs = require('fs')
```

### 7.2.2 读取指定文件中的内容

1、 fs.readFile()语法格式

使用fs.readFile()方法，可以**读取**指定文件中的内容，语法格式如下：

```js
fs.readFile(path[,options],callback)
```

参数解读：

- 参数1：必选参数，字符串，表示文件的路径。
- 参数2：可选参数，表示以什么编码格式来读取文件。
- 参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。

2、fs.readFile()的示例代码

以utf8的编码格式，读取指定文件的内容，并打印err和dataStr的值：

```js
const fs = require('fs')
fs.readFile('./files/11.txt','utf8',function(err,dataStr) {
    console.log(err)
    console.log('------')
    console.log(dataStr)
})
// 如果读取成功，则err的值为null
// 如果读取失败，则err的值为错误对象，dataStr的值为undefined
```

![1650729043677](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650729043677.png)

![1650729065950](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650729065950.png)

3、判断文件是否读取成功

可以判断err对象是否为null，从而知晓文件读取的结果：

```js
const fs = require('fs')
fs.readFile('./files/1.txt','utf8',function(err,result) {
    if (err) {
        return console.log('文件读取失败！'+err.message)
    }
    console.log('文件读取成功，内容是：'+result)
})
```

### 7.2.3 向指定的文件中写入内容

1、fs.writeFile()的语法格式

使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下：

```js
fs.writeFile(file,data[,options],callback)
```

参数解读：

- 参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。
- 参数2：必选参数，表示要写入的内容。
- 参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8。
- 参数4：必选参数，文件写入完成后的回调函数

2、fs.writeFile()的示例代码

```js
const fs = require('fs')
fs.writeFile('./files/2.txt','Hello Node.js!',function(err) {
    console.log(err)
})
// 如果文件写入成功，则err的值等于null
// 如果文件写入失败，则err的值为一个 错误对象
```

3、判断文件是否写入成功

可以判断err对象是否为null，从而知晓文件写入的结果：

```js
const fs = require('fs')
fs.writeFile('F:/files/2.txt','Hello Node.js!',function(err) {
    if (err) {
        return console.log('文件写入失败！' + err.message)
    }
    console.log('文件写入成功！')
})
```

### 7.2.4 练习-考试成绩管理

使用fs文件系统模块，将素材目录下**成绩.txt**文件中的考试数据，整理到**成绩-ok.txt**文件中。

整理前，成绩.txt文件中的数据格式如下：

```js
小红=99 小白=100 小黄=70 小黑=66 小绿=88
```

整理完成之后，希望得到的**成绩-ok.txt**文件的数据格式如下：

```js
小红：99
小白：100
小黄：70
小黑：66
小绿：88
```

核心实现步骤：

（1）导入需要的fs文件系统模块

（2）使用**fs.readFile()**方法，读取素材目录下的**成绩.txt**文件

（3）判断文件是否读取失败

（4）文件读取成功后，处理成绩数据

（5）将处理完成的成绩数据，调用**fs.writeFile()**方法，写入到新文件**成绩-ok.txt**中

```js
const fs = require("fs")
fs.readFile("../素材/成绩.txt", "utf8", function (err, dataStr) {
  if (err) {
    return console.log("读取文件失败！" + err.message)
  }
  // console.log("读取文件成功！" + dataStr)
  // 1. 先把成绩的数据，按照空格进行分割，得到数组
  const arrOld = dataStr.split(" ")
  // console.log(arrOld)
  // 2. 循环分割后的数组，对每一项数据，进行字符串的替换
  const arrNew = []
  arrOld.forEach(item => {
    arrNew.push(item.replace("=", "："))
  })
  // 3. 把新数组中的每一项进行合并，得到一个新的字符串
  const newStr = arrNew.join("\r\n")

  // 4. 把处理完毕的数据写入到新文件中
  fs.writeFile("./files/成绩-ok.txt", newStr, function (err) {
    if (err) {
      return console.log("写入文件失败！" + err.message)
    }
    console.log("成绩写入成功！")
  })
})
```

### 7.2.5 fs模块-路径动态拼接的问题

在使用fs模块操作文件时，如果提供的操作路径是以./或../开头的**相对路径**时，很容易出现路径动态拼接错误的问题。

原因：代码在运行的时候，**会以执行node命令时所处的目录**，**动态拼接**出被操作文件的完整路径。

![1650772132392](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650772132392.png)

解决方案：在使用fs模块操作文件时，**直接提供完整的路径**，不要提供以./或../开头的**相对路径**，从而防止动态拼接的问题。

```js
// 完整的路径
"C:\\Users\\Administrator\\Desktop\\前端开发\\A练习9-Node.js基础\\day1\\code\\files\\1.txt"
```

以上提供的完整路径：移植性非常差，不利于维护。

```js
// __dirname表示当前文件所处的目录
fs.readFile(__dirname + "/files/1.txt", "utf8", function (err, dataStr) {
  if (err) {
    return console.log("读取文件失败！" + err.message)
  }
  console.log("读取文件成功！" + dataStr)
```

__dirname不会随着执行node命令时所处的目录的变化而变化，它是一个固定的值。

## 7.3 path路径模块

### 7.3.1 什么是path路径模块

**path模块**是Node.js官方提供的、用来**处理路径**的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。

例如：

- path.join()方法，用来**将多个路径片段拼接成一个完整的路径字符串**
- path.basename()方法，用来从路径字符串中，将文件名解析出来

如果要在JavaScript代码中，使用path模块来处理路径，则需要使用如下的方式先导入它：

```js
const path = require('path')
```

### 7.3.2 路径拼接

1. path.join()的语法格式

   使用path.join()方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：

   ```js
   path.join([...paths])
   ```

   参数解读：

   - ...paths  < string >路径片段的序列
   - 返回值：< string >

2. path.join()的代码示例

   ```js
   const pathStr = path.join('/a','/b/c','../','./d','e')
   console.log(pathStr)  // 输出a/b/d/e
   
   const pathStr2 = path.join(__dirname,'./files/1.txt')
   console.log(pathStr2) // 输出当前文件所处目录\files\1.txt
   ```

   注意：../会抵消前面的一层路径

   注意：**今后凡是涉及到路径拼接的操作，都要使用path.join()方法进行处理**。不要直接使用+进行字符串的拼接。

### 7.3.3 获取路径中的文件名

1. path.basename()的语法格式

   使用path.basename()方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：

   ```js
   path.basename(path[,ext])
   ```

   参数解读：

   - path < string >必选参数，表示一个路径的字符串
   - ext < string >可选参数，表示文件扩展名
   - 返回：< string >表示路径中的最后一部分

2. path.basename()方法，可以从一个文件路径中，获取到文件的名称部分：

   ```js
   const fpath = 'a/b/c/index.html'  // 文件的存放路径
   var fullName = path.basename(fpath)
   console.log(fullName)  // 输出 index.html
   var nameWithoutExt = path.basename(fpath,'.html')
   console.log(nameWithoutExt)  // 输出index
   ```

### 7.3.4 获取路径中的文件扩展名

1. path.extname()的语法格式

   使用path.extname()方法，可以获取路径中的扩展名部分，语法格式如下：

   ```js
   path.extname(path)
   ```

   参数解读：

   - path < string > 必选参数，表示一个路径的字符串
   - 返回：< string >返回得到的扩展名字符串

2. path.extname()的代码示例

   ```js
   const fpath = '/a/b/c/index.html'  // 路径字符串
   const fext = path.extname(fpath)
   console.log(fext)  // 输出.html
   ```

### 7.3.5 综合案例-时钟案例

#### 7.3.5.1 案例要实现的功能

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650784771352.png" alt="1650784771352" style="zoom:67%;" />

#### 7.3.5.2 案例的实现步骤

（1）创建两个正则表达式，分别用来匹配< style > 和 < script > 标签

导入需要的模块并创建正则表达式

```js
// 1.1 导入fs文件系统模块
const fs = require('fs')
// 1.2 导入path路径处理模块
const path = require('path')
// 1.3 匹配< style >< /style >标签的正则
// 其中，\s表示空白字符；\S表示非空白字符；*表示匹配任意次
const regStyle = /<style>[\s\S]*<\/style>/
// 1.4 匹配< script >< /script >标签的正则
const regScript = /<script>[\s\S]*<\/script>/
```

（2）使用fs模块，读取需要被处理的HTML文件

```js
// 2.1 读取需要被处理的HTML文件
fs.readFile(path.join(--dirname,'../素材/index.html'),'utf8',(err,dataStr)=>{
    // 2.2 读取HTML文件失败
    if (err) {
        return console.log('读取文件失败！'+err.message)
    }
    // 2.3 读取HTML文件成功后，调用对应的方法，解析出css、js和html文件
    resolveCSS(dataStr)
    resolveJS(dataStr)
    resolveHTML(dataStr)
})
```

（3）自定义resolveCSS方法，来写入index.css样式文件

```js
// 3.1 处理css样式
function resolveCSS(htmlStr) {
    // 3.2 使用正则提取页面中的<style></style>标签
    const r1 = regStyle.exec(htmlStr)
    // 3.3 将提取出来的样式字符串，做进一步的处理
    const newCSS = r1[0].replace('<style>','').replace('</style>,'')
    // 3.4 将提取出来的css样式，写入到index.css文件中
    fs.writeFile(path.join(__dirname,'./clock/index.css'),newCSS,err=>{
        if (err) {
            return console.log('写入CSS样式失败！' + err.message)
        }
        console.log('写入CSS样式成功！')
    })                                                
}
```

（4）自定义resolveJS方法，来写入index.js脚本文件

```js
// 4.1 处理js脚本
function resolveJS(htmlStr) {
    // 4.2 使用正则提取页面中的<script></script>标签
    const r2 = regScript.exec(htmlStr)
    // 34.3 将提取出来的样式字符串，做进一步的处理
    const newJS = r2[0].replace('<script>','').replace('</script>,'')
    // 4.4 将提取出来的js脚本，写入到index.js文件中
    fs.writeFile(path.join(__dirname,'./clock/index.js'),newJS,err=>{
        if (err) {
            return console.log('写入JavaScript脚本失败！' + err.message)
        }
        console.log('写入JS脚本成功！')
    })                                                
}
```

（5）自定义resolveHTML方法，来写入index.html文件

```js
// 5. 处理html文件
function resolveHTML(htmlStr) {
    // 5.1 使用字符串中的replace方法，把内嵌的<style>和<script>标签，替换为外联的<link>和<script>标签
    const newHTML = htmlStr.replace(regStyle,'<link rel="stylesheet" href="./index.css">').replace(regScript,'<script src=",.index.js"></script>')
    // 5.2 将替换完成之后的html代码，写入到index.html文件中
    fs.writeFile(path.join(__dirname,'./clock/index.html'),newHTML,err=>{
        if (err) return console.log('写入HTML文件失败！'+err.message)
        console.log('写入HTML页面成功！')
    })
}
```

#### 7.3.5.3 案例的两个注意点

（1）fs.writeFile()方法只能用来创建文件，不能用来创建路径

一定要先创建文件夹，然后才能在文件夹中写入相应的文件

（2）重复调用fs.writeFile()写入同一个文件，新写入的内容会覆盖之前的旧内容

## 7.4 http模块

### 7.4.1 什么是http模块

回顾：什么是客户端、什么是服务器？

在网络节点中，负责消费资源的电脑，叫做客户端；**负责对外提供网络资源**的电脑，叫做服务器。



**http**模块是Node.js官方提供的、**用来创建web服务器**的模块。通过http模块提供的http.createServer()方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。



如果要希望使用http模块创建Web服务器，则需要先导入它：

```js
const http = require('http')
```

### 7.4.2 进一步理解http模块的作用

服务器和普通电脑的**区别**在于，服务器上安装了**web服务器软件**，例如：IIS、**Apache**等。通过安装这些服务器软件，就能把一台普通的电脑变成一台web服务器。

在Node.js中，我们**不需要使用**IIS、Apache等这些**第三方web服务器软件**。因为我们可以基于Node.js提供的http模块，**通过几行简单的代码，就能轻松的手写一个服务器软件**，从而对外提供web服务。

### 7.4.3 服务器相关的概念

1. IP地址

   **IP地址**就是互联网上**每台计算机的唯一地址**，因此IP地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方IP地址的前提下，才能与对应的电脑之间进行数据通信。

   IP地址的格式：通常用“**点分十进制**”表示成(**a.b.c.d**)的形式，其中，a,b,c,d都是0~255之间的十进制整数。例如：用点分十进制表示的IP地址(192.168.1.1)

   注意：

   （1）**互联网中每台Web服务器，都有自己的IP地址**，例如：大家可以在Windows的终端中运行ping www.baidu.com命令，即可查看到百度服务器的IP地址。

   （2）在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入**127.0.0.1**这个IP地址，就能把自己的电脑当做一台服务器进行访问了。

2. **域名**和**域名服务器**

   尽管IP地址能够唯一地标记网络上的计算机，但IP地址是以长串的数字，不直观，而且不便于记忆，于是人们又发明了另一套**字符型的地址方案**，即所谓的**域名(Domain Name)地址**。

   IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做**域名服务器**(DNS, Domain Name Server)的电脑中。使用者只需要通过记好的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，**域名服务器就是提供IP地址和域名之间的转换服务的服务器**。

   注意：

   （1）单纯使用IP地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。

   （2）在开发测试期间，127.0.0.1对应的域名是localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。

3. 端口号

   计算机中的端口号，就好像现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。

   同样的道理，在一台电脑中，可以运行成百上千个web服务器。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以准确地交给对应的web服务进行处理。

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650796460718.png" alt="1650796460718" style="zoom:67%;" />

   注意：

   （1）每个端口号不能同时被多个web服务占用。

   （2）在实际应用中，URL中的**80端口可以被省略**。

### 7.4.4 创建最基本的web服务器

#### 7.4.4.1 创建web服务器的基本步骤

（1）导入http模块

如果希望在自己的电脑上创建一个web服务器，从而对外提供web服务，则需要导入http模块：

```js
const http = require('http')
```

（2）创建web服务器实例

调用**http.createServer()**方法，即可快速创建一个web服务器实例：

```js
const server = http.createServer()
```

（3）为服务器实例绑定**request**事件，**监听客户端的请求**

```js
// 使用服务器实现的.on()方法，为服务器绑定一个request事件
server.on('request',(req, res) => {
    // 只要有客户端来请求我们自己的服务器，就会触发 request 事件，从而调用这个事件处理函数
    console.log('Someone visit our web server')
})
```

（4）启动服务器

调用服务器实例的.listen()方法，即可启动当前的web服务器实例：

```js
// 调用server.listen(端口号，cb回调)方法，即可启动web服务器
server.listen(80, () => {
    console.log('http server running at http://127.0.0.1')
})
```

#### 7.4.4.2 req请求对象

只要服务器接收到了客户端的请求，就会调用通过**serve.on()**为服务器绑定的**request事件处理函数**。

如果想要在事件处理函数中，**访问与客户端相关的数据或属性**，可以使用如下的方式：

```js
serve.on('request',(req)=>{
    // req 是请求对象，它包含了与客户端相关的数据和属性，例如：
    // req.url是客户端请求的URL地址
    // req.method是客户端的method请求类型
    const str = `Your request url is ${req.url}, and request method is ${req.method}`
    console.log(str)
})
```

#### 7.4.4.3 res响应对象

在服务器的request事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下的方式：

```js
server.on('request',(req,res)=>{
    // res是响应对象，它包含了与服务器相关的数据和属性，例如：
    // 要发送到客户端的字符串
    const str = `Your request url is ${req.url}, and request method is ${req.method}`
    // req.end() 方法的作用：
    // 向客户端发送指定的内容，并结束这次请求的处理过程
    res.end(str)
})
```

#### 7.4.4.5 解决中文乱码问题

当调用res.end()方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式：

```js
server.on('request',(req,res)=>{
    // 发送的内容包含中文
    const str = `您请求的url地址是${req.url},请求的method类型是${req.method}`
    // 为了防止中文显示乱码的问题，需要设置响应头Content-Type的值为text/html; charset=utf-8
    res.setHeader('Content-Type','text/html; charset=utf-8')
    // 把包含中文的内容，响应给客户端
    res.end(str)
})
```

### 7.4.5 根据不同的url响应不同的html内容

#### 7.4.5.1 核心实现步骤

（1）获取**请求的url地址**

（2）设置**默认的响应内容**为404 Not found

（3）判断用户请求的是否为/或/index.html首页

（4）判断用户请求的是否为/about.html关于页面

（5）设置**Content-Type**响应头，防止中文乱码

（6）使用**res.end()**把内容响应给客户端

#### 7.4.5.2 动态响应内容

```js
server.on('request',(req,res)=>{
	const url = req.url                        // 1. 获取请求的url地址
    let content = '<h1>404 Not found</h1>'     // 2. 设置默认的内容为404 Not found
    if (url === '/' || url === '/index.html') {
        content = '<h1>首页</h1>'               // 3. 用户请求的是首页
    } else if (url === '/about.html') {
        content = '<h1>关于页面</h1>'            // 4. 用户请求的是关于页面
    }
    res.setHeader('Content-Type','text/html; charset=utf-8')  // 5. 设置响应头，防止中文乱码
    res.send(content)                                         // 6. 把内容发送给客户端
})
```

### 7.4.6 案例--实现clock时钟的web服务器

#### 7.4.6.1 核心思路

把文件的**实际存放路径**，作为每个资源的**请求url地址**。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650876391472.png" alt="1650876391472" style="zoom:80%;" />

**服务器充当的角色：就是一个字符串的搬运工**

#### 7.4.6.2 实现步骤

（1）导入需要的模块

```js
// 1.1 导入http模块
const http = require('http')
// 1.2 导入fs文件系统模块
const fs = require('fs')
// 1.3 导入path路径处理模块
const path = require('path')
```

（2）创建基本的web服务器

```js
// 2.1 创建web服务器
const server = http.createServer()
// 2.2 监听web服务器的request事件
server.on('request',function(req,res) {})
// 2.3 启动web服务器
server.listen(80,function() {
    console.log('server running at http://127.0.0.1')
})
```

（3）将资源的请求url地址映射为文件的存放路径

```js
// 3.1 获取到客户端请求的url地址
const url = req.url
// 3.2 把请求的url地址，映射为本地文件的存放路径
const fpath = path.join(__dirname, url)
```

（4）读取文件内容并响应给客户端

```js
// 4.1 根据“映射”过来的文件路径读取文件
fs.readFile(fpath,'utf8',(err,dataStr)=>{
    // 4.2 读取文件失败后，向客户端响应固定的“错误消息”
    if (err) return res.end('404 Not found.')
    // 4.3 读取文件成功后，将“读取成功的内容”响应给客户端
    res.end(dataStr)
})
```

（5）优化资源的请求路径

```js
// 将 3.2 的实现方式，改为如下代码
// 5.1 预定义空白的文件存放路径
let fpath = ''
if (url === '/') {
    // 5.2 如果请求的路径为/，则手动指定文件的存放路径
    fpath = path.join(__dirname, './clock/index.html')
} else {
    // 5.3 如果请求的路径不为/，则动态拼接文件的存放路径
    fpath = path.join(__dirname, '/clock', url)
}
```

# 8. 模块化

目标：

- 能够说出模块化的好处
- 能够知道CommonJS规定了哪些内容
- 能够说出Node.js中模块的三大分类各自是什么
- 能够使用npm管理包
- 能够了解什么是规范的包结构
- 能够了解模块的加载机制

## 8.1 模块化的基本概念

### 8.1.1 什么是模块化

**模块化**是指解决一个**复杂问题**时，自顶向下逐层**把系统分成若干模块的过程**。对于整个系统来说，**模块是可组合、分解和更换的单元**。

1. 现实中的模块化

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650953194828.png" alt="1650953194828" style="zoom:67%;" />

2. 编程领域中的模块化

   编程领域中的模块化，就是**遵守固定的规则**，把一个**大文件**拆成**独立并相互依赖**的**多个小模块**。

   把代码进行模块化拆分的好处：

   （1）提高了代码的**复用性**

   （2）提高了代码的**可维护性**

   （3）可以实现**按需加载**

### 8.1.2 模块化规范

**模块化规范**就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。

例如：

- 使用什么样的语法格式来**引用模块**
- 在模块中使用什么样的语法格式**向外暴露成员**

**模块化规范的好处**：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。

## 8.2 Node.js中的模块化

### 8.2.1 Node.js中模块的分类

Node.js中根据模块来源的不同，将模块分为了3大类，分别是：

- **内置模块**（内置模块是由Node.js官方提供的，例如fs、path、http）
- **自定义模块**（用户创建的每个.js文件，都是自定义模块）
- **第三方模块**（**由第三方开发出来的模块**，并非官方提供的内置模块，也不是用户创建的自定义模块，**使用前需要先下载**）

### 8.2.2 加载模块

使用强大的require()方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如：

```js
// 1. 加载内置的fs模块
const fs = require('fs')

// 2. 加载用户的自定义模块
const custom = require('./custom.js')

// 3. 加载第三方模块
const moment = require('moment')
```

注意：（1）使用require()方法加载其它模块时，会执行被加载模块中的代码。

​			（2）在使用require加载用户自定义模块期间可以省略.js的后缀名

### 8.2.3 Node.js中的模块作用域

1. 什么是模块作用域

   和**函数作用域**类似，在自定义模块中定义的**变量、方法**等成员，**只能在当前模块内被访问**，这种**模块级别的访问限制**，叫做**模块作用域**。

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650955277499.png" alt="1650955277499" style="zoom: 80%;" />

2. 模块作用域的好处

   防止了全局变量污染的问题

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650957599459.png" alt="1650957599459" style="zoom: 80%;" />

   在这里username的打印结果为ls

### 8.2.4 向外共享模块作用域中的成员

#### 8.2.4.1 module对象

在每个.js自定义模块中都有一个module对象，它里面**存储了和当前模块有关的信息**，打印如下：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650958243255.png" alt="1650958243255" style="zoom: 67%;" />

#### 8.2.4.2 module.exports对象

在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用。默认情况下，module.exports是一个空对象{}

外界用**require()方法**导入自定义模块时，得到的就是module.exports所指向的对象。

#### 8.2.4.3 共享成员时的注意点

使用require()方法导入模块时，导入的结果，**永远以module.exports指向的对象为准**。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650960287600.png" alt="1650960287600" style="zoom: 80%;" />

#### 8.2.4.4 exports对象

由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，Node提供了**exports**对象。**默认情况下，exports和module.exports指向同一个对象**。最终共享的结果，还是以module.exports指向的对象为准。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650961019667.png" alt="1650961019667" style="zoom:67%;" />

#### 8.2.4.5 exports和module.exports的使用误区

时刻谨记，导入require()模块时，得到的永远是**module.exports**指向的对象：

![1650962513227](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650962513227.png)

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650962680872.png" alt="1650962680872" style="zoom:80%;" />

​                                                                                        {age: 20}

**注意**：为了防止混乱，建议大家不要在同一个模块中同时使用exports和module.exports

### 8.2.5 Node.js中的模块化规范

Node.js遵循了CommonJS模块化规范，CommonJS规定了**模块的特性**和**各模块之间如何相互依赖**。

CommonJS规定：

（1）每个模块内部，**module变量**代表当前模块。

（2）module变量是一个对象，它的exports属性(即**module.exports**)**是对外的接口**。

（3）加载某个接口，其实是加载该模块的module.exports属性。**require()方法用于加载模块**。

### 8.3 npm与包

### 8.3.1 包

#### 8.3.1.1 什么是包

Node.js中的**第三方模块**又叫做**包**。

就像**电脑**和**计算机**指的是相同的东西，**第三方模块**和**包**指的是同一个概念，只不过叫法不同。

#### 8.3.1.2 包的来源

不同于Node.js中的内置模块和自定义模块，**包是由第三方个人或团队开发出来的**，免费供所有人使用。

**注意**：Node.js中的包都是免费且开源的，不需要付费即可免费下载使用。

#### 8.3.1.3 为什么需要包

由于Node.js的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发时，效率很低。

**包是基于内置模块封装出来的**，提供了更高级、更方便的API，**极大的提高了开发效率**。

**包**和**内置模块**之间的关系，类似于**jQuery**和**浏览器内置API**之间的关系。

#### 8.3.1.4 从哪里下载包

国外有一家 IT 公司，叫做 npm, Inc. 这家公司旗下有一个非常著名的网站： https://www.npmjs.com/ ，它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心！

到目前位置，全球约 1100 多万的开发人员，通过这个包共享平台，开发并共享了超过 120 多万个包 供我们使用。

npm, Inc. 公司提供了一个地址为 https://registry.npmjs.org/ 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。

注意：

- 从 https://www.npmjs.com/ 网站上搜索自己所需要的包
- 从 https://registry.npmjs.org/服务器上下载自己需要的包

#### 8.3.1.5 如何下载包

npm, Inc. 公司提供了一个包管理工具，我们可以使用这个包管理工具，从 https://registry.npmjs.org/ 服务器把需要的包下载到本地使用。

这个包管理工具的名字叫做 Node Package Manager（简称 npm 包管理工具），这个包管理工具随着 Node.js 的安装包一起被安装到了用户的电脑上。

大家可以在终端中执行 npm -v 命令，来查看自己电脑上所安装的 npm 包管理工具的版本号：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650964500045.png" alt="1650964500045" style="zoom:50%;" />

### 8.3.2 npm初体验

#### 8.3.2.1 格式化时间的传统做法

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650965378950.png" alt="1650965378950" style="zoom:80%;" />

#### 8.3.2.2 格式化时间的高级做法

（1）使用npm包管理工具，在项目中安装格式化时间的包moment

（2）使用require()导入格式化时间的包

（3）参考moment的官方API文档对时间进行格式化

```js
// 1. 导入moment包
const moment = require('moment')

// 2. 参考moment官方API文档，调用对应的方法，对时间进行格式化
// 2.1 调用moment()方法，得到当前的事件
// 2.2 针对当前的时间，调用format()方法，按照指定的格式进行时间的格式化
const dt = moment().format('YYYY-MM-DD HH:mm:ss')

console.log(dt)  // 输出 2022-04-26 17:35:26
```

#### 8.3.2.3 在项目中安装包的命令

如果想在项目中安装指定名称的包，需要运行如下的命令：

```js
npm install 包的完整名称
```

上述的装包命令，可以简写为如下格式：

```js
npm i 完整的包名称
```

![1650966361133](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650966361133.png)

#### 8.3.2.4 初次装包后多了哪些文件

初次装包完成后，在项目文件夹下多一个叫做**node_modules**的文件夹和**package-lock.json**的配置文件。

其中：

node_modules文件夹用来存放所有已安装到项目中的包。require()导入第三方包时，就是从这个目录中查找并加载包。

package-lock.json配置文件用来记录node_modules目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。

注意：程序员不要手动修改node_modules或package-lock.json文件中的任何代码，npm包管理工具会自动维护它们。

#### 8.3.2.5 安装指定版本的包

默认情况下，使用npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过@符号指定具体的版本，例如：

```js
npm i moment @2.22.2
```

#### 8.3.2.6 包的语义化版本规范

包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如**2.29.3**

其中每一位数字所代表的含义如下：

第1位数字：**大版本**

第2位数字：**功能版本**

第3位数字：Bug修复版本

**版本号提升的原则**：只要前面的版本号增长了，则后面的版本号**归零**。

### 8.3.3 包管理配置文件

npm规定，在**项目根目录**中，必须提供一个叫做**package.json**的包管理配置文件。用来记录与项目有关的一些配置信息。例如：

- 项目的名称、版本号、描述等
- 项目中都用到了哪些包
- 哪些包只在**开发期间**会用到
- 哪些包在**开发**和**部署**时都需要用到

#### 8.3.3.1 多人协作的问题

![1650969642278](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650969642278.png)

#### 8.3.3.2 如何记录项目中安装了哪些包

在项目根目录中，创建一个叫做package.json的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除node_modules目录之后，在团队成员之间共享项目的源代码。



**注意**：今后在项目开发中，一定要把node_modules文件夹，添加到.gitignore忽略文件中。

#### 8.3.3.3 快速创建package.json

npm包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建package.json这个包管理配置文件：

```js
npm init -y
```

注意：

（1）上述命令**只能在英文的目录下成功运行**！所以，项目文件夹的名称一定要使用英文命名，**不要使用中文，不能出现空格**。

（2）运行 npm install 命令安装包的时候，npm 包管理工具会自动把**包的名称和版本号**，记录到 package.json 中。

#### 8.3.3.4 dependencies节点

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650971051527.png" alt="1650971051527" style="zoom:67%;" />

package.json 文件中，有一个 **dependencies 节点**，专门用来记录您使用 npm install 命令安装了哪些包。

#### 8.3.3.5 一次性安装所有的包

当我们拿到了一个**剔除了node_modules**的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。

否则会报类似于下面的错误：

![1650971362994](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650971362994.png)

可以运行npm install命令(或npm i)一次性安装所有的依赖包：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650971505618.png" alt="1650971505618" style="zoom:80%;" />

#### 8.3.3.6 卸载包

可以运行 npm uninstall 命令，来卸载指定的包：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650971668966.png" alt="1650971668966" style="zoom:80%;" />

注意：npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。

#### 8.3.3.7 devDependencies节点

如果某些包**只在项目开发阶段**会用到，在**项目上线之后不会用到**，则建议把这些包记录到 devDependencies 节点中。
与之对应的，如果某些包在**开发**和**项目上线之后都需要用到**，则建议把这些包记录到 dependencies 节点中。

可以使用如下的命令，将包记录到 devDependencies 节点中：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650972261081.png" alt="1650972261081" style="zoom:80%;" />

### 8.3.4 解决下包速度慢的问题

#### 8.3.4.1 为什么下包速度慢

在使用 npm 下包的时候，默认从国外的 https://registry.npmjs.org/ 服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢。

扩展阅读 - 海底光缆：

- https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/4107830
- https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/10520363
- https://baike.baidu.com/item/APG/23647721?fr=aladdin

#### 8.3.4.2 淘宝NPM镜像服务器

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650972620153.png" alt="1650972620153" style="zoom:80%;" />

淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包**同步**到国内的服务器，然后在国内提供下包的服务。从而极大的提高了下包的速度。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650972652779.png" alt="1650972652779" style="zoom:80%;" />

**扩展：**
**镜像（Mirroring）**是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。

#### 8.3.4.3 切换npm的下包镜像源

下包的镜像源，指的就是**下包的服务器地址**。

```js
# 查看当前的下包镜像源
npm config get registry
# 将下包的镜像源切换为淘宝镜像源
npm config set registry=https://registry.npm.taobao.org/
# 检查镜像源是否下载成功
npm config get registry
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650973102256.png" alt="1650973102256" style="zoom:80%;" />

#### 8.3.4.4 nrm

为了更方便的切换下包的镜像源，我们可以安装 **nrm** 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源。

```js
# 通过npm包管理器，将nrm安装为全局可用的工具
npm i nrm -g
# 查看所有可用的镜像源
nrm ls
# 将下包的镜像源切换为 taobao 镜像源
nrm use taobao
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650973621469.png" alt="1650973621469" style="zoom: 67%;" />

### 8.3.5 包的分类

使用npm包管理工具下载的包，共分类两大类，分别是(项目包和全局包)：

- **项目包**

  那些被安装到**项目**的 **node_modules** 目录中的包，都是项目包。

  项目包又分为两类，分别是：

  - 开发依赖包（被记录到 **devDependencies** 节点中的包，只在开发期间会用到）
  - 核心依赖包（被记录到 **dependencies** 节点中的包，在开发期间和项目上线之后都会用到）

  ![1650973807192](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650973807192.png)

- **全局包**

  在执行 npm install 命令时，如果提供了 **-g** 参数，则会把包安装为**全局包**。

  全局包会被安装到 **C:\Users\用户目录\AppData\Roaming\npm\node_modules** 目录下。

  ![1650973955134](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650973955134.png)

  注意：

  （1）只有**工具性质的包**，才有全局安装的必要性。因为它们提供了好用的终端命令。

  （2）判断某个包是否需要全局安装后才能使用，可以**参考官方提供的使用说明**即可。

- **i5ting_toc(属于全局npm包)**

  i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下：

  <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1650974264327.png" alt="1650974264327" style="zoom:80%;" />

### 8.3.6 规范的包结构

在清楚了包的概念、以及如何下载和使用包之后，接下来，深入了解一下**包的内部结构**。

一个规范的包，它的组成结构，必须符合以下3点要求：

（1）包必须以**单独的目录**而存在

（2）包的顶级目录下要必须包含**package.json**这个包管理配置文件

（3）package.json中必须包含**name，version，main**这三个属性，分别代表**包的名字、版本号、包的入口**

注意：以上3点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：

https://yarnpkg.com/zh-Hans/docs/package-json

### 8.3.7 开发属于自己的包

#### 8.3.7.1 需要实现的功能

（1）格式化日期

```js
// 1. 导入自己的包
const itheima = require('itheima-utils')
// 功能1：格式化日期
const dt = itheima.dateFormat(new Date())
// 输出 2022-04-28 11:31:46
console.log(dt)
```

（2）转义HTML中的特殊字符

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651116860692.png" alt="1651116860692" style="zoom:80%;" />

（3）还原HTML中的特殊字符

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651117128791.png" alt="1651117128791" style="zoom:80%;" />

#### 8.3.7.2 初始化包的基本结构

（1）新建itheima-tools文件夹，作为**包的根目录**

（2）在itheima-tools文件夹中，新建如下三个文件：

- package.json（包管理配置文件）
- index.js（包的入口文件）
- README.md（包的说明文档）

#### 8.3.7.3 初始化package.json

```js
{
    "name": "itheima-tools-xnn",
    "version": "1.0.0",
    "main": "index.js"
    "description": ["itheima", "dateFormat", "escape"],
    "license": "ISC"
}
```

关于更多license许可协议相关的内容，可参考https://www.jianshu.com/p/86251523e898

#### 8.3.7.4 在index.js中定义格式化时间的方法

```js
// 格式化时间的方法
function dateFormat(dateStr) { /* 省略其余代码 */}

// 补零的方法
function padZero(n) {
    return n > 9 ? n : "0" + n
}

module.exports = {
    dateFormat
}
```

#### 8.3.7.5 在index.js中定义转义HTML的方法

```js
function htmlEscape(htmlStr) {
    return html.Str.replace(/<|>|"|&/g, (match) => {
        switch (match) {
            case '<':
                return '&lt;'
            case '>':
                return '&gt;'
            case '""':
                return '&quot'
            case '&':
                return '&amp'
        }
    })
}
```

#### 8.3.7.6 在index.js中定义还原HTML方法

```js
function htmlUnEscape(str) {
    return str.replace(/&lt;|&gt;|&quot;|&amp;/g,(match) => {
        switch (match) {
            case '&lt;':
                return '<'
            case '&gt;':
                return '>'
            case '&quot':
                return '"'
            case '&amp':
                return '&'
        }
    })
}
```

#### 8.3.7.7 将不同的功能进行模块化拆分

（1）将格式化时间的函数，拆分到src→**dateFormat.js**中

（2）将处理HTML字符串的功能，拆分到src→**htmlEscape.js**中

（3）在index.js中，导入两个模块，得到需要向外共享的方法

（4）在index.js中，使用module.exports把对应的方法共享出去

#### 8.3.7.8 编写包的说明文档

包根目录中的**README.md**文件，是**包的使用说明文档**。通过它，我们可以事先把包的使用说明，以markdown的格式写出来，方便用户参考。

README 文件中具体写什么内容，没有强制性的要求；只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。
我们所创建的这个包的 README.md 文档中，会包含以下 6 项内容：
**安装方式、导入方式、格式化时间、转义 HTML 中的特殊字符、还原 HTML 中的特殊字符、开源协议**

### 8.3.8 发布包

#### 8.3.8.1 注册npm账号

（1）访问 https://www.npmjs.com/ 网站，点击 **sign up** 按钮，进入注册用户界面

（2）填写账号相关的信息：Full Name、**Public Email、Username、Password**

（3）点击 **Create an Account** 按钮，注册账号

（4）登录邮箱，点击**验证链接**，进行账号的验证

#### 8.3.8.2 登录npm账号

npm账号注册完成后，可以在终端中执行**npm login**命令，一次输入用户名、密码、邮箱后，即可登录成功。

注意：在运行npm login命令之前，必须先把**下包的服务器**地址切换为**npm的官方服务器**。否则会导致发布包失败！

#### 8.3.8.3 把包发布到npm上

将终端切换到包的根目录之后，运行 **npm publish**命令，即可将包发布到npm上（注意：**包名不能雷同**）

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651154816262.png" alt="1651154816262" style="zoom:67%;" />

#### 8.3.8.3 删除已发布的包

运行 **npm unpublish 包名 --force**命令，即可从npm删除已发布的包。

![1651155138625](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651155138625.png)

注意：

（1）npm unpublish 命令只能删除**72小时**以内发布的包

（2）npm unpublish 删除的包，在**24小时**内不允许重复发布

（3）发布包的时候要慎重，**尽量不要往npm上发布没有意义的包**！

## 8.4 模块的加载机制

### 8.4.1 优先从缓存中加载

**模块在第一次加载后会被缓存**。这也意味着多次调用require()不会导致模块的代码被执行多次。

注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而**提高模块的加载效率**。

### 8.4.2 内置模块的加载机制

内置模块是由Node.js官方提供的模块，**内置模块的加载优先级最高**。

例如：require(‘fs’)始终返回内置的fs模块，即使在node_modules目录下有名字相同的包也叫做fs。

### 8.4.3 自定义模块的加载机制

使用 require() 加载自定义模块时，必须指定以 **./** 或 **../** 开头的**路径标识符**。在加载自定义模块时，如果没有指定 ./ 或 ../ 这样的路径标识符，则 node 会把它当作**内置模块**或**第三方模块**进行加载。

同时，在使用require()导入自定义模块时，如果省略了文件的扩展名，则Node.js会**按顺序**分别尝试加载以下的文件：

（1）按照**确切的文件名**进行加载

（2）补全**.js**扩展名进行加载

（3）补全**.json**扩展名进行加载

（4）补全**.node**扩展名进行加载

（5）加载失败，终端报错

#### 8.4.5 第三方模块的加载机制

如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘../’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。

**如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。**

例如，假设在 'C:\Users\itheima\project\foo.js' 文件里调用了 require('tools')，则 Node.js 会按以下顺序查找：
 （1） C:\Users\itheima\project\node_modules\tools
 （2）C:\Users\itheima\node_modules\tools
 （3）C:\Users\node_modules\tools
 （4）C:\node_modules\tools

### 8.4.6 目录作为模块

当把目录作为模块标识符，传递给require()进行加载的时候，有三种加载方式：

（1）在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口
（2）如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。
（3）如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module 'xxx'



# 9. Express

目标：

- 能够使用express.static()快速托管静态资源
- 能够使用express路由精简项目结构
- 能够使用常见的express中间件
- 能够使用express创建API接口
- 能够在express中启用cors跨域资源共享

## 9.1 初识Express

### 9.1.1 Express简介

#### 9.1.1.1 什么是Express

官方给出的概念：Express是**基于Node.js平台**，**快速、开放、极简**的**Web开发框架**。

通俗的理解：Express的作用和Node.js内置的http模块类似，是专门用来创建服务器的。

**Express的本质**：就是一个npm上的第三方包，提供了快速创建Web服务器的便捷方法。

Express的中文官网： http://www.expressjs.com.cn/

#### 9.1.1.2 进一步理解Express

思考：不使用Express能否创建Web服务器

答案：能，使用Node.js提供的原生http模块即可。

思考：既生瑜何生亮（有了http内置模块，为什么还要用Express）

答案：http模块用起来复杂，开发效率低；Express是基于内置的http模块进一步封装出来的，能够极大的提高开发效率。

思考：http内置模块与Express是什么关系？

答案：类似于浏览器中Web API和jQuery的关系。后者是基于前者进一步封装出来的。

#### 9.1.1.3 Express能做什么

对于前端程序员来说，最常见的两种服务器，分别是：

- Web网站服务器：专门对外提供Web网页资源的服务器
- API接口服务器：专门对外提供API接口的服务器

使用Express，我们可以方便、快速的创建**Web网站**的服务器或**API接口**的服务器。

### 9.1.2 Express的基本使用

#### 9.1.2.1 安装

在项目所处的目录中，运行如下的终端命令，即可将express安装到项目中使用：

```js
npm i express@4.17.1
```

#### 9.1.2.2 创建基本的Web服务器

```js
// 1. 导入express
const express = require('express')
// 2. 创建 web 服务器
const app = express()
// 3. 调用app.listen(端口号，启动成功后的回调函数)，启动服务器
app.listen(80, () => {
    console.log('express server running at http://127.0.0.1')
})
```

#### 9.1.2.3 监听GET请求

通过app.get()方法，可以监听客户端的GET请求，具体的语法格式如下：

```js
// 参数1：客户端请求的URL地址
// 参数2：请求对应的处理函数
//       req:请求对象（包含了与请求相关的属性与方法）
//       res:响应对象（包含了与响应相关的属性与方法）
app.get('请求URL',function(req,res) { /* 处理函数 */})
```

#### 9.1.2.4 监听POST请求

通过app.post()方法，可以监听客户端的POST请求，具体的语法格式如下：

```js
// 参数1：客户端请求的URL地址
// 参数2：请求对应的处理函数
//       req:请求对象（包含了与请求相关的属性与方法）
//       res:响应对象（包含了与响应相关的属性与方法）
app.post('请求URL',function(req,res) { /* 处理函数 */})
```

#### 9.1.2.5 把内容响应给客户端

通过**res.send()**方法，可以把处理好的内容，发送给客户端：

```js
app.get('/user',(req,res)=>{
    // 向客户端发送JSON对象
    res.send({name: 'zs', age: 20, gender: '男'})
})

app.post('/user',(req,res)=>{
    // 向客户端发送文本内容
    res.send('请求成功')
})
```

#### 9.1.2.6 获取URL中携带的查询参数

通过**req.query**对象，可以访问到客户端通过**查询字符串**的形式，发送到服务器的参数：

```js
app.get('/',(req,res)=>{
    // req.query默认是一个空对象
    // 客户端使用 ?name=zs&age=20 这种查询字符串的形式，发送到服务器的参数
    // 可以通过req.query对象访问到，例如：
    // req.query.name    req.query.age
    console.log(req.query)
})
```

#### 9.1.2.7 获取URL中的动态参数

通过**req.params**对象，可以访问到URL中，通过**：**匹配到的**动态参数**：

```js
// URL地址中，可以通过 :参数名 的形式，匹配动态参数值
app.get('/user/:id',(req,res)=>{
    // req.params 默认是一个空对象
    // 里面存放着通过 : 动态匹配到的参数值
    console.log(req.params)
    res.send(req.params)
})
```

注意点：(1) 冒号后面的字符串的名称是自己取的，只要合理合法就行。（2）动态参数的值可以是多个

```js
app.get('/user/:ids/:username',(req,res)=>{
    console.log(req.params)
    res.send(req.params)
})
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651210608071.png" alt="1651210608071" style="zoom:50%;" />

### 9.1.3 托管静态资源

#### 9.1.3.1 express.static()

express提供了一个非常好用的函数，叫做express.static()，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将public目录下的图片、CSS文件、JavaScript文件对外开放访问了：

```js
app.use(express.static('public'))
```

现在，你就可以访问 public 目录中的所有文件了：
http://localhost:3000/images/bg.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/login.js

**注意**：Express在**指定的**静态目录中查找文件，并对外提供资源的访问路径。因此，**存放静态文件的目录名不会出现在URL中**。

#### 9.1.3.2 托管多个静态资源目录

如果要托管多个静态资源目录，请多次调用express.static()函数：

```js
app.use(express.static('public'))
app.use(express.static('files'))
```

访问静态资源文件时，express.statics()函数会根据目录的添加顺序查找所需的文件。

#### 9.1.3.3 挂载路径前缀

如果希望在托管的**静态资源访问路径**之前，**挂载路径前缀**，则可以使用如下的方式：

```js
app.use('/publish',express.static('./publish'))
```

现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了：
http://localhost:3000/public/images/kitten.jpg
http://localhost:3000/public/css/style.css
http://localhost:3000/public/js/app.js

#### 9.1.4 nodemon

#### 9.1.4.1 为什么要使用nodemon

在编写Node.js项目的时候，如果修改了项目的代码，则需要频繁的手动close掉，然后再重新启动，非常繁琐。

现在，我们可以调用nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能**监听项目文件的变动**，当代码被修改后，nodemon**会自动帮我们重启项目**，极大方便了开发和调试。

#### 9.1.4.2 安装nodemon

在终端中，运行如下命令，即可将nodemon安装为全局可用的工具：

```js
npm install -g nodemon
```

#### 9.1.4.3 使用nodemon

当基于Node.js编写了一个网站应用的时候，传统的方式，是运行**node app.js**命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目。

现在，我们可以将node命令替换为nodemon命令，使用**nodemon app.js**来启动项目。这样做的好处是：代码被修改之后，会被nodemon监听到，从而实现自动重启项目的效果。

```js
node app.js
# 将上面的终端命令，替换为下面的终端命令，即可实现自动重启项目的效果
nodemon app.js
```

## 9.2 Express路由

### 9.2.1 路由的概念

#### 9.2.1.1 什么是路由

广义上来讲，路由就是**映射关系**。

#### 9.2.1.2 现实生活中的路由

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651214222226.png" alt="1651214222226" style="zoom:67%;" />

在这里，路由是**按键**与**服务**之间的**映射关系**

#### 9.2.1.3 Express中的路由

在Express中，路由指的是**客户端的请求**与**服务器处理函数**之间的**映射关系**。

Express中的路由分3部分组成，分别是请求的类型、请求的URL地址、处理函数，格式如下：

```js
app.METHOD(PATH,HANDLER)
```

#### 9.2.1.4 Express中的路由的例子

```js
// 匹配GET请求，且请求URL为 /
app.get('/', (req,res)=>{
	res.send('Hello World!')
})

// 匹配POST请求，且请求URL为 / 
app.post('/', (req,res)=>{
	res.send('Got a POST request')
})
```

#### 9.2.1.5 路由的匹配过程

每当一个请求达到服务器之后，**需要先经过路由的匹配**，只有匹配成功之后，才会调用对应的处理函数。

在匹配时，会按照路由的顺序进行匹配，如果**请求类型**和**请求URL**同时匹配成功，则Express会将这次请求，转交给对应的function函数进行处理。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651216315125.png" alt="1651216315125" style="zoom:80%;" />

路由匹配的注意点：

（1）按照定义的**先后顺序**进行匹配(谁在前面谁的匹配优先级最高，谁在后面谁的匹配优先级低)

（2）**请求类型**和**请求的URL**同时匹配成功，才会调用对应的处理函数

### 9.2.2 路由的使用

#### 9.2.2.1 最简单的方法

在Express中使用路由最简单的方式，就是把路由挂载到app上，示例代码如下：

```js
const express = require('express')
// 创建Web服务器，命名为app
const app = express()

// 挂载路由
app.get('/',(req,res) =>{res.send('Hello World.')})
app.post('/',(req,res) =>{res.send('Post Request.')})

// 启动Web服务器
app.listen(80, ()=>{console.log('server running at http://127.0.0.1')})
```

#### 9.2.2.2 模块化路由

为了**方便对路由进行模块化的管理**，Express**不建议**将路由直接挂载到app上，而是**推荐将路由抽离为单独的模块**。

将路由抽离为单独模块的步骤如下：

（1）创建路由模块对应的.js文件

（2）调用**express.Router()**函数创建路由对象

（3）向路由对象上挂载具体的路由

（4）使用**module.exports**向外共享路由对象

（5）使用**app.use()**函数注册路由模块

#### 9.2.2.3 创建路由模块

```js
var express = require('express')  // 1. 导入express
var router = express.Router()     // 2. 创建路由对象

router.get('/user/list',function(req,res) {
    // 3. 挂载获取用户列表的路由
    res.send('Get user list.')
})
router.post('/user/add',function(req,res) {
    // 4. 挂载添加用户的路由
    res.send('Add new user.')
})
module.exports=router             // 5. 向外导出路由对象
```

#### 9.2.2.4 注册路由模块

```js
// 1. 导入路由模块
const userRouter = require('./router/user.js')

// 2. 使用app.use()注册路由模块
app.use(userRouter)
```

**注意：app.use()  函数的作用，就是来注册全局中间件**

#### 9.2.2.5 为路由模块添加前缀

类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：

```js
// 1. 导入路由模块
const userRouter = require('./router/user.js')

// 2. 使用app.use()注册路由模块，并添加统一的访问前缀 /api
app.use('/api',userRouter)
```

## 9.3 Express中间件

### 9.3.1 中间件的概念

#### 9.3.1.1 什么是中间件

中间件（Middlewave），特指**业务流程**的**中间处理环节**。

#### 9.3.1.2 现实生活中的例子

在处理污水的时候，一般要经过**三个处理环节**，从而保证处理过后的废水，达到排放标准。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651223622063.png" alt="1651223622063" style="zoom:80%;" />

处理污水的这三个中间处理环节，就可以叫做中间件。

#### 9.3.1.3 Express中间件的调用流程

当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行**预处理**。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651223956824.png" alt="1651223956824" style="zoom:80%;" />

#### 9.3.1.4 Express中间件的格式

Express的中间件，**本质**上就是一个**function处理函数**，Express中间件的格式如下：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651224330305.png" alt="1651224330305" style="zoom:80%;" />

注意：**中间件函数的形参列表中，必须包含next参数**。而路由处理函数中只包含req和res。

#### 9.3.1.5 next函数的作用

**next函数**是实现**多个中间件连续调用**的关键，它表示把流转关系**转交**给下一个**中间件**或**路由**。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651224793280.png" alt="1651224793280" style="zoom:80%;" />

### 9.3.2 Express中间件的初体验

#### 9.3.2.1 定义中间件函数

可以通过如下的方式，定义一个最简单的中间件函数：

```js
// 常量mw所指向的，就是一个中间件函数
const mw = function(req,res,next) {
    console.log('这是一个最简单的中间件函数')
    // 注意：在当前中间件的业务处理完毕后，必须调用next()函数
    // 表示把流转关系转交给下一个中间件或路由
    next()
}
```

#### 9.3.2.2 全局生效的中间件

客户端发起的**任何请求**，到达服务器之后，**都会触发的中间件**，叫做全局生效的中间件。

通过调用**app.use(中间件函数)**，即可定义一个**全局生效**的中间件，示例代码如下：

```js
// 常量mw所指向的，就是一个中间件函数
const mw = function(req,res,next) {
    console.log('这是一个最简单的中间件函数')
    next()
}

// 全局生效的中间件
app.use(mw)
```

#### 9.3.2.3 定义全局中间件的简化形式

```js
// 全局生效的中间件
app.use(function(req,res,next) {
    console.log('这是一个最简单的中间件函数')
    next()
})
```

#### 9.3.2.4 中间件的作用

多个中间件之间，**共享同一份req和res**。基于这样的特性，我们可以在**上游**的中间件中，**统一**为req或res对象添加自定义的属性或方法，供**下游**的中间件或路由进行使用。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651228819670.png" alt="1651228819670" style="zoom:80%;" />

#### 9.3.2.5 定义多个全局中间件

可以使用app.use()**连续定义多个**全局中间件。客户端请求到达服务器之后，会按照中间件**定义的先后顺序**依次进行调用，实例代码如下：

```js
app.use(function(req,res,next) {  // 第1个全局中间件
    console.log('调用了第1个全局中间件')
    next()
})
app.use(function(req,res,next) {  // 第2个全局中间件
    console.log('调用了第2个全局中间件')
    next()
})
app.get('/user',(req,res)=>{
    // 请求这个路由，会依次触发上述两个全局中间件
    res.send('Home page.')
})
```

#### 9.3.2.6 局部生效的中间件

**不使用app.use()**定义的中间件，叫做**局部生效的中间件**，示例代码如下：

```js
// 定义中间件函数mw1
const mw1 = function(req,res,next) {
    console.log('这是中间件函数')
    next()
}
// mw1这个中间件只在“当前路由中生效”，这种用法属于“局部生效的中间件”
app.get('/',mw1,function(req,res) {
    res.send('Home page.')
})
// mw1这个中间件不会影响下面这个路由
app.get('/user',function(req,res) {
    res.send('User page.')
})
```

#### 9.3.2.7 定义多个局部中间件

可以在路由中，通过如下两种等价的方式，使用多个局部中间件：

```js
// 以下两种写法是“完全等价”的，可根据自己的喜好，选择任意一种方式进行使用
app.get('/',mw1,mw2,(req,res)=>{
    res.send('Home page.')
})

app.get('/',[mw1,mw2],(req,res)=>{
    res.send('Home page.')
})
```

#### 9.3.2.8 了解中间件的5个使用注意事项

（1）一定要在**路由之前**注册中间件

（2）客户端发送过来的请求，**可以连续调用多个**中间件进行处理

（3）执行完中间件的业务代码之后，**不要忘记调用next()函数**

（4）为了**防止代码逻辑混乱**，调用next()函数后不要再写额外的代码

（5）连续调用多个中间件时，多个中间件之间，**共享**req和res对象

### 9.3.3 中间件的分类

为了方便大家理解和记忆中间件的作用，Express官方把**常见的中间件用法**，分成了**5大类**，分别是：

（1）**应用级别**的中间件

通过**app.use()**或**app.get()**或**app.post()**，**绑定到app实例上的中间件**，叫做应用级别的中间件，代码示例如下：

```js
// 应用级别的中间件（全局中间件）
app.use((req,res,next)=>{
    next()
})

// 应用级别的中间件（局部中间件）
app.get('/',mw1,(req,res)=>{
    res.send('Home page.')
})
```

（2）**路由级别**的中间件

绑定到express.Router()实例上的中间件，叫做路由级别的中间件。它的用法和应用级别的中间件没有任何区别。只不过，应用级别中间件时绑定到app实例上，路由级别中间件绑定到router实例上，代码示例如下：

```js
var app = express()
vae router = express.Router()

// 路由级别的中间件
router.use(function(req,res,next) {
    console.log('Time:',Date.now())
    next()
})

app.use('/',router)
```

（3）**错误级别**的中间件

错误级别中间件的**作用**：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。

**格式**：错误级别中间件的function处理函数中，**必须有4个形参**，形参顺序从前到后，分别是(**err**,req,res,next)。

```js
app.get('/',function(req,res) {   // 1. 路由
    throw new Error('服务器内部发生了错误！')  // 1.1 抛出一个自定义的错误
    res.send('Home page.')
})
app.use(function(err,req,res,next) {  // 2. 错误级别的中间件
    console.log('发生了错误：'+err.message)  // 2.1 在服务器打印错误消息
    res.send('Error!'+err.message)   // 2.2 向客户端响应错误相关的内容
})
```

**注意**：错误级别的中间件，**必须注册在所有路由之后**！

（4）**Express内置**的中间件

自 Express 4.16.0 版本开始，Express 内置了 **3 个**常用的中间件，极大的提高了 Express 项目的开发效率和体验：

（1） **express.static** 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（**无兼容性**）
 （2）**express.json** 解析 JSON 格式的请求体数据（**有兼容性**，仅在 4.16.0+ 版本中可用）
 （3）**express.urlencoded** 解析 URL-encoded 格式的请求体数据（**有兼容性**，仅在 4.16.0+ 版本中可用）

```js
// 配置解析 application/json格式数据的内置中间件
app.use(express.json())
// 配置解析 application/x-www-form-urlencoded格式数据的内置中间件
app.use(express.urlencoded({extended: false}))
```

（5）**第三方**的中间件

非Express官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，可以可以按需下载并配置第三方中间件，从而提高项目的开发效率。

例如：在express@4.16.0之前的版本中，经常使用body-parse这个第三方中间件，来解析请求体数据。使用步骤如下：

（1）运行**npm install body-parse**安装中间件

（2）使用**require导入**中间件

（3）调用**app.use()注册并使用**中间件

**注意**：Express内置的express.urlencoded中间件，就是基于body-parse这个第三方中间件进一步封装出来的。

### 9.3.4 自定义中间件

#### 9.3.4.1 需求描述与实现步骤

自己**手动模拟**一个类似于express.urlencoded这样的中间件，来**解析POST提交到服务器的表单数据**。

实现步骤：

（1）定义中间件

使用app.use()来定义全局生效的中间件，代码如下：

```js
app.use(function(req,res,next) {
    // 中间件的业务逻辑
})
```

（2）监听req的**data**事件

在中间件中，需要监听req对象的data事件，来获取客户端发送到服务器的数据。

如果数据量比较大，无法一次性发送完毕，则客户端会**把数据切割后，分批发送到服务器**。所以 data 事件可能会触发多次，每一次触发 data 事件时，**获取到数据只是完整数据的一部分**，需要手动对接收到的数据进行拼接。

```js
// 定义变量，用来存储客户端发送过来的请求数据
let str = ''
// 监听req对象的data事件（客户端发送过来的新的请求体数据）
req.on('data',(chunk)=>{
    // 拼接请求体数据，隐式转换为字符串
    str += chunk
})
```

（3）监听req的end事件

当请求体数据接收完毕之后，会自动触发req的end事件。

因此，我们可以在req的end事件中，拿到并处理完整的请求体数据。示例代码如下：

```js
// 监听req对象的end事件（请求发送完毕后自动触发）
req.on('end',()=>{
    // 打印完整的请求体数据
    console.log(str)
    // TODO: 把字符串格式的请求体数据，解析成对象格式
})
```

（4）使用querystring模块解析请求体数据

Node.js内置了一个querystring模块，专门用来处理查询字符串。通过这个模块提供的parse()函数，可以轻松把查询字符串，解析成对象的格式。示例代码如下：

```js
// 导入处理querystring的Node.js内置模块
const qs = require('querystring')

// 调用qs.parse()方法，把查询字符串解析为对象
const body = qs.parse(str)
```

（5）将解析出来的数据对象挂载为req.body

上游的中间件和下游的中间件及路由之间，共享同一份req和res。因此，可以将解析出来的数据，挂载为req的自定义属性，命名为req.body，供下游使用。示例代码如下：

```js
req.on('end',()=>{
	const body = qs.parse(str)  // 调用qs.parse()方法，把查询字符串解析为对象
    req.body = body             // 将解析出来的请求对象，挂载为req.body属性
    next()                      // 最后，一定要调用next()函数，执行后续的业务逻辑
})
```

（6）将自定义中间件封装为模块

为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651248584845.png" alt="1651248584845" style="zoom:80%;" />

## 9.4 使用Express写接口

### 9.4.1 创建基本的服务器

```js
// 导入express模块
const express = require('express')
// 创建express的服务器实例
const app = express()

// write your code here...

// 调用app.listen方法，指定端口号并启动web服务器
app.listen(80,function() {
    console.log('Express server running at http://127.0.0.1')
})
```

### 9.4.2 创建API路由模块

```js
// apiRouter.js 【路由模块】
const express = require('express')
const apiRouter = express.Router()

// bind your router here

module.exports = apiRouter

// --------------------

// app.js【导入并注册路由模块】
const apiRouter = require('./apiRouter.js')
app.use('/api',apiRouter)
```

### 9.4.3 编写GET接口

```js
apiRouter.get('/get',(req,res)=>{
    // 1. 获取到客户端通过查询字符串，发送到服务器的数据
    const query = req.query
    // 2. 调用res.send()方法，把数据响应给客户端
    res.send({
        status: 0,           // 状态，0表示成功，1表示失败
        msg: 'GET请求成功！',  // 状态描述
        data: query          // 需要响应给客户端的具体数据
    })
})
```

### 9.4.4 编写POST接口

```js
apiRouter.post('/post',(req,res)=>{
    // 1. 获取到客户端通过查询字符串，发送到服务器的数据
    const body = req.body
    // 2. 调用res.send()方法，把数据响应给客户端
    res.send({
        status: 0,            // 状态，0表示成功，1表示失败
        msg: 'POST请求成功！',  // 状态描述
        data: body            // 需要响应给客户端的具体数据
    })
})
```

注意：如果要获取URL-encoded格式的请求体数据，必须配置中间件app.use(**express.urlencoded**({extended: false}))

### 9.4.5 CORS跨域资源共享

#### 9.4.5.1 接口的跨域问题

刚才编写的GET和POST接口，存在一个很严重的问题：**不支持跨域请求**。

解决接口跨域问题的方案主要有两种：

（1）**CORS**（主流的解决方案，推荐使用）

（2）**JSONP**（有缺陷的解决方案：只支持GET请求）

#### 9.4.5.2 使用cors中间件解决跨域问题

cors是Express的一个第三方中间件。通过安装和配置cors中间件，可以很方便地解决跨域问题。

使用步骤分为如下3步：

（1）运行 npm install cors 安装中间件

（2）使用const cors = require(‘cors’) 导入中间件

（3）在路由之前**调用 app.use(cors())** 配置中间件

#### 9.4.5.3 什么是CORS

CORS（Cross-Origin Resource Shearing，跨域资源共享）由一系列**HTTP响应头**组成，**这些HTTP响应头决定浏览器是否阻止前端JS代码跨域获取资源**。

浏览器的**同源安全策略**默认会阻止网页“跨域”获取资源。但如果接口服务器**配置了CORS相关的HTTP响应头**，就可以**解除浏览器端的跨域访问限制**。

![1651473836777](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651473836777.png)

#### 9.4.5.4 CORS的注意事项

（1）CORS主要在**服务器端**进行配置。客户端浏览器**无须做任何额外的配置**，即可请求开启了CORS的接口。

（2）CORS 在浏览器中**有兼容性**。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。

#### 9.4.5.5 CORS响应头部 - Access-Control-Allow-Origin

响应头部中可以携带一个Access-Control-Allow-Origin字段，其语法如下：

```js
Access-Control-Allow-Origin: <origin> | *
```

其中，origin参数的值指定了允许访问该资源的外域URL。

例如，下面的字段值将只允许http://itcast.cn的请求。

```js
res.setHeader('Access-Control-Allow-Origin', 'http://itcast.cn')
```

如果指定了Access-Control-Allow-Origin字段的值为**通配符***，表示允许来自任何域的请求，示例代码如下：

```js
res.setHeader('Access-Control-Allow-Origin', '*')
```

#### 9.4.5.6 CORS响应头部-Access-Control-Allow-Headers

默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：

Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）
如果客户端向服务器**发送了额外的请求头信息**，则需要在**服务器端**，通过 Access-Control-Allow-Headers **对额外的请求头进行声明**，否则这次请求会失败！

![1651474688790](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651474688790.png)

#### 9.4.5.7 CORS响应头部-Access-Control-Allow-Methods

默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。

如果客户端希望通过 **PUT、DELETE** 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods来**指明实际请求所允许使用的 HTTP 方法**。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651474874849.png" alt="1651474874849" style="zoom:80%;" />

#### 9.4.5.8 CORS请求的分类

客户端在请求CORS接口时，根据请求方式和请求头的不同，可以将CORS的请求分为两大类，分别是：

（1）简单请求

同时满足以下两大条件的请求，就属于简单请求：

- 请求方式：GET、POST、HEAD三者之一
- HTTP头部信息不超过以下几种字段：**无自定义头部字段**、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）

（2）预检请求

只要符合以下任何一个条件的请求，都需要进行预检请求：

- 请求方式为GET、POST、HEAD之外的请求Methods类型
- 请求头中包含自定义头部字段
- 向服务器发送了application/json格式的数据

在浏览器与服务器正式通信之前，浏览器会**先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求**，所以这一次的 OPTION 请求称为“预检请求”。**服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据**。

#### 9.4.5.9 简单请求和预检请求的区别

简单请求的特点：客户端与服务器之间只会发生一次请求。

预检请求的特点：客户端与服务器之间会发生两次请求，OPTION预检请求成功之后，才会发起真正的请求。

### 9.4.6 JSONP接口

#### 9.4.6.1 回顾JSONP的概念和特点

**概念**：浏览器端通过< script >标签的src属性，请求服务器上的数据，同时，服务器返回一个函数的调用，这种请求数据的方式叫做JSONP。

特点：

（1）JSONP不属于真正的Ajax请求，因为它没有使用XMLHttpRequest这个对象。

（2）JSONP仅支持GET请求，不支持POST、PUT、DELETE等请求。

#### 9.4.6.2 创建JSONP接口的注意事项

如果项目中**已经配置了CORS**跨域资源共享，为了**防止冲突，必须在配置CORS中间件之前声明JSONP的接口**。否则JSONP接口会被处理成开启了CORS的接口。示例代码如下：

```js
// 优先创建 JSONP 接口【这个接口不会被处理成CORS接口】
app.get('/api/jsonp',(req,res)=>{})

// 再配置CORS中间件【后续的所有接口，都会被处理成CORS接口】
app.use(cors())

// 这是一个开启了CORS的接口
app.get('/appi/get',(req,res)=>{})
```

#### 9.4.6.3 实现JSONP接口的步骤

（1）**获取**客户端发送过来的**回调函数的名字**

（2）**得到要**通过JSONP形式**发送给客户端的数据**

（3）根据前两步得到的数据，**拼接出一个函数调用的字符串**

（4）把上一步拼接得到的字符串，响应给客户端的<script>标签进行解析执行

#### 9.4.6.4 实现JSONP接口的具体代码

```js
app.get('/api/jsonp',(req,res)=>{
    // 1. 获取客户端发送过来的回调函数的名字
    const funcName = req.query.callback
    // 2. 得到要通过JSONP形式发送给客户端的数据
    const data = {name: 'zs', age: 22}
    // 3. 根据前两步得到的数据，拼接出一个函数调用的字符串
    const scriptStr = `${funcName}(${JSON.stringify(data)})`
    // 4. 把上一步拼接得到的字符串，响应给客户端的< script >标签进行解析执行
    res.send(scriptStr)
})
```

#### 9.4.6.5 在网页中使用jQuery发起JSONP请求

调用$.ajax()函数，**提供JSONP的配置选项**，从而发起JSONP请求，示例代码如下：

```js
$('#btnJSONP').on('click',function() {
    $.ajax({
        method: 'GET',
        url: 'http://127.0.0.1/api/jsonp',
        dataType: 'jsonp',  // 表示要发起JSONP的请求
        success: function(res) {
            console.log(res)
        }
    })
})
```

# 10. 数据库与身份认证

学习目标：

## 10.1 数据库的基本概念

### 10.1.1 什么是数据库

数据库（database）是用来**组织、存储和管理**数据的仓库。

当今世界是一个充满数据的互联网世界，充斥着大量的数据。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。

为了方便管理互联网世界中的数据，就有了**数据库管理系统**的概念（简称：数据库）。用户可以对数据库中的数据进行**新增、查询、更新、删除**等操作。

### 10.1.2 常见的数据库及分类

市面上的数据库有很多种，最常见的数据库有如下几个：

- MySQL数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise）
- Oracle数据库（收费）
- SQL Server 数据库 （收费）
- Mongodb数据库（Community + Enterprise）

其中，MySQL、Oracle、SQL Server属于传统型数据库（又叫做：关系型数据库或SQL数据库），这三者的设计理念相同，用法比较类似。

而Mongodb属于新型数据库（又叫做：非关系型数据库或NoSQL数据库），它在一定程度上弥补了传统型数据库的缺陷。

### 10.1.3 传统数据库的数据组织结构

数据的组织结构：指的就是数据以什么样的结构进行存储。

传统型数据库的数据组织结构，与Excel中数据的组织结构比较类似。

因此，我们可以对比着Excel来了解和学习传统型数据库的组织结构。

#### 10.1.3.1 Excel的数据组织结构

每个Excel中，数据的组织结构分别为**工作簿、工作表、数据行、列**这4大部分组成。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651480751332.png" alt="1651480751332" style="zoom:80%;" />

#### 10.1.3.2 传统型数据库的数据组织结构

在传统型数据库中，数据的组织结构分为**数据库(database)、数据表(table)、数据行(row)、字段(field)**这4个大部分组成。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651481047120.png" alt="1651481047120" style="zoom:80%;" />

#### 10.1.3.3 实际开发中库、表、行、字段的关系

（1）在实际项目开发中，一般情况下，每个项目都对应**独立的数据库**。

（2）不同的数据，要存储到数据库的不同表中，例如：用户数据存储到users表中，图书数据存储到books表中。

（3）每个表中具体存储哪些信息，由字段来决定，例如：我们可以为users表设计id、username、password这3个字段。

（4）表中的行，代表每一条具体的数据。

## 10.2 安装并配置MySQL

### 10.2.1 了解需要安装哪些MySQL相关的软件

对于开发人员来说，只需要安装MySQL Server和MySQL Workbench这两个软件，就能满足开发的需要了。

- MySQL Server：专门用来提供数据存储和服务的软件。
- MySQL Workbench：可视化的MySQL管理工具，通过它，可以方便的操作存储在MySQL Server中的数据。

## 10.3 MySQL的基本使用

## 10.4 在Express中操作MySQL

## 10.5 前后端的身份认证

### 10.5.1 Web开发模式

目前主流的Web开发模式有两种，分别是：

（1）基于**服务端渲染**的传统Web开发模式

服务端渲染的概念：服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用Ajax这样的技术额外请求页面的数据。代码示例如下：

```js
app.get('/index.html',(req,res) => {
    // 1. 要渲染的数据
    const user = {name: 'zs', age: 20}
    // 2. 服务器通过字符串的拼接，动态生成HTML内容
    const html = `<h1>姓名：${user.name},年龄: ${user.age}</h1>`
    // 3. 把生成好的页面内容响应给客户端，因此，客户端拿到的是带有真实数据的HTML页面
    res.send(html)
})
```

优点：

- 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。
- 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。

缺点：

- 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。
- 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发。

（2）基于**前后端分离**的新型Web开发模式

前后端分离的概念：前后端分离的开发模式，依赖于Ajax技术的广泛应用。简而言之，前后端分离的Web开发模式，就是后端只负责提供API接口，前端使用Ajax调用接口的开发模式。

优点：

- 开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。
- 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。
- 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。

缺点：

不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用 Vue、React 等前端框架的 SSR （server side render）技术能够很好的解决 SEO 问题！）

### 10.5.2 如何选择Web开发模式

- 比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染
- 而类似后台管理项目，交互性比较强，不需要考虑SEO，那么就可以使用前后端分离的开发模式

另外，具体使用何种开发模式并不是绝对的，为了**同时兼顾首页的渲染速度和前后端分离的开发效率**，一些网站采用了首屏服务器端渲染+其他页面前后端分离的开发模式。

### 10.5.3 身份认证

#### 10.5.3.1 什么是身份认证

在Web开发中，各大网站的手机验证码登录、邮箱密码登录、二维码扫描等都属于用户身份认证。

#### 10.5.3.2 为什么需要身份认证

身份认证的目的，是为了确认当前所声称为某种身份的用户，确实是所声称的用户。

#### 10.5.3.3 不同开发模式下的身份认证

对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：

（1）服务端渲染推荐使用**Session认证机制**

（2）前后端分离推荐使用**JWT认证机制**

### 10.5.4 Session认证机制

#### 10.5.4.1 HTTP协议的无状态性

了解HTTP协议的无状态性是进一步学习Session认证机制的必要前提。

HTTP协议的无状态性，指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651490484615.png" alt="1651490484615" style="zoom:80%;" />

#### 10.5.4.2 如何突破HTTP无状态的限制

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651490563461.png" alt="1651490563461" style="zoom:80%;" />

#### 10.5.4.3 什么是Cookie

Cookie是存储在用户浏览器中的一段不超过4KB的字符串。它由一个名称(Name)、一个值(Value)和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。

不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前名下所有未过期的Cookie一同发送到服务器。

**Cookie的几大特性：**

（1）自动发送

（2）域名独立

（3）过期时限

（4）4KB限制

#### 10.5.4.4  Cookie在身份认证中的作用

客户端第一次请求服务器的时候，服务器**通过响应头的形式**，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在浏览器中。

随后，当客户端浏览器每次请求服务器的时候，浏览器会**自动**将身份认证相关的 Cookie，**通过请求头的形式**发送给服务器，服务器即可验明客户端的身份。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651491531766.png" alt="1651491531766" style="zoom:80%;" />

#### 10.5.4.5 Cookie不具有安全性

由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。

注意：千万不要使用Cookie**存储重要且隐私的数据**！比如用户的身份信息、密码等。

#### 10.5.4.6 提高身份认证的安全性

为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以在收银机上进行刷卡认证。只有收银机确认存在的会员卡，才能被正常使用。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651491868315.png" alt="1651491868315" style="zoom:80%;" />

这种会员卡+刷卡认证的设计理念，就是Session认证机制的精髓。

#### 10.5.4.7 Session的工作原理

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651492442281.png" alt="1651492442281" style="zoom:80%;" />

### 10.5.5 在Express中使用Session认证

#### 10.5.5.1 安装express-session中间件

在Express项目中，只需要安装express-session中间件，即可在项目中使用session认证：

```js
npm install express-session
```

#### 10.5.5.2 配置express-session中间件

express-session中间件安装成功后，需要通过app.use()来注册session中间件，示例代码如下：

```js
// 1. 导入session中间件
const session = require('express-session')
// 2. 配置Session中间件
app.use(session({
    secret: 'Keyboard Cat',  // secret 属性的值可以为任意字符串
    resave: false,     // 固定写法
    saveUninitialized: true   // 固定写法
}))
```

#### 10.5.5.3 向session中存数据

当express-session中间件配置成功后，即可通过req.session来访问和使用session对象，从而存储用户的关键信息：

```js
app.post('/api/login',(req,res) => {
    // 判断用户提交的登录信息是否正确
    if (req.body.username = !== 'admin' || req.body.password !== '000000') {
        return res.send({status: 1, msg: '登录失败'})
    }
    
    req.session.user = req.body  // 将用户的信息，存储到Session中
    req.session.islogin = true   // 将用户的登录状态，存储到Session中
    
    res.send({status: 0, msg: '登录成功'})
})
```

#### 10.5.5.4 从session中取数据

可以直接从req.session对象上获取之前存储的数据，示例代码如下：

```js
// 获取用户姓名的接口
app.get('/api/username',(req,res) => {
    // 判断用户是否登录
    if (!req.session.islogin) {
        return res.send({status: 1, msg: 'fail'})
    }
    res.send({status: 0, msg: 'success', username: req.session.user.username})
})
```

#### 10.5.5.5 清空session

调用**req.session.destroy()**函数，即可清空服务器保存的session信息。

```js
// 退出登录的接口
app.post('/api/logout',(req,res)=>{
    // 清空当前客户端对应的session信息
    req.session.destroy()
    res.send({
        status: 0,
        msg: '退出登录成功'
    })
})
```

### 10.5.6 JWT认证机制

#### 10.5.6.1 了解Session认证的局限性

Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。

注意：

- 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。
- 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。

#### 10.5.6.2 什么是JWT

JWT（英文全称：JSON Web Token）是目前**最流行的跨域认证解决方案**。

#### 10.5.6.3 JWT的工作原理

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651495308277.png" alt="1651495308277" style="zoom:67%;" />

总结：用户的信息通过Token字符串的形式，保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份。

#### 10.5.6.4 JWT的组成部分

JWT通常由三部分组成，分别是Header（头部）、Payload（有效荷载）、Signature（签名）。

三者之间使用英文的“.”分隔，格式如下：

```js
Header.Payload.Signature
```

下面是 JWT 字符串的示例：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651495642996.png" alt="1651495642996" style="zoom:80%;" />

#### 10.5.6.5 JWT的三个部分各自代表的含义

JWT 的三个组成部分，从前到后分别是 Header、Payload、Signature。

其中：

- Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。
- Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651495928145.png" alt="1651495928145" style="zoom:67%;" />



#### 10.5.6.6 JWT的使用方式

客户端收到服务器返回的JWT之后，通常会将它存储在localStorage或sessionStorage中。

此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 请求头的 Authorization 字段中，格式如下：

```js
Authorization: Bearer <token>
```

### 10.5.7 在Express中使用JWT

1. 安装JWT相关的包

   运行如下命令，安装如下两个包

   ```js
   npm install jsonwebtoken express-jwt
   ```

   其中：

   - jsonwebtoken用于生成JWT字符串
   - express-jwt用于将JWT字符串解析还原成JSON对象

2. 导入JWT相关的包

   使用require()函数，分别导入

   ```js
   // 1. 导入用于生成JWT字符串的包
   const jwt = require('jsonwebtoken')
   // 2. 导入用于将客户端发送过来的JWT字符串，解析还原成JSON对象的包
   const expressJWT = require('express-jwt')
   ```

3. 定义secret密钥

   为了保证JWT字符串的安全性，防止JWT字符串在网络传输过程中被别人破解，需要专门定义一个用于加密和解密的secret密钥：

   （1）当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串

   （2）当把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密

   ```js
   // 3. secret密钥的本质：就是一个字符串
   const secretKey = 'itheima No1'
   ```

4. 在登录成功后生成JWT字符串

   调用jsonwebtoken包提供的sign()方法，将用户的信息加密成JWT字符串，响应给客户端：

   ```js
   // 登录窗口
   app.post('/api/login',function(req,res) => {
            // 用户登录成功后生成JWT字符串，通过token属性响应给客户端
            res.send({
            status: 200,
            message: '登陆成功',
            // 调用jwt.sign()生成JWT字符串，三个参数分别是： 用户信息对象、加密密钥、配置对象
            token: jwt.sign({username: userinfo.username}, secretKey, {expiresIn: '30s'})
            })
         })
   ```

5. 将JWT字符串还原为JSON对象

   客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的Authorization字段，将Token字符串发送到服务器进行身份认证。

   此时，服务器可以通过express-jwt这个中间件，自动将客户端发送过来的Token解析还原成JSON对象：

   ```js
   // 使用app.use()来注册中间件
   // expressJWT({secret: secretKey})  就是用来解析Token的中间件
   // .unless({path: [/^\/api\//]}) 用来指定哪些接口不需要访问权限
   app.use(expressJWT({secret: secretKey}).unless({path: [/^\/api\//]}))
   ```

6. 使用req.user获取用户信息

   当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串中解析出来的用户信息了，示例代码如下：

   ```js
   // 这是一个有权限的API接口
   app.get('/admin/getinfo',function(req,res) => {
           console.log(req.user)
   		res.send({
               status: 200,
               message: '获取用户信息成功',
               data: req.user
           })
        })
   ```

7. 捕获解析JWT失败后产生的错误

   当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行。我们可以通过 Express 的错误中间件，捕获这个错误并进行相关的处理，示例代码如下：

   ```js
   app.use((err,req,res,next) => {
       // token解析失败导致的错误
       if (err.name === 'UnauthorizedError') {
           return res.send({status: 401, message: '无效的token'})
       }
       // 其他原因导致的错误
       res.send({status: 500, message: '未知错误'})
   })
   ```

   



